/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity ^0.8.17;

import "@partylikeits1983/statistics_solidity/contracts/dependencies/prb-math/PRBMathSD59x18.sol";
import "./GenericTokenomics.sol";
import "./TokenomicsConstants.sol";
import "./interfaces/IDonatorBlacklist.sol";
import "./interfaces/IOLAS.sol";
import "./interfaces/IServiceTokenomics.sol";
import "./interfaces/IToken.sol";
import "./interfaces/ITreasury.sol";
import "./interfaces/IVotingEscrow.sol";
import "@partylikeits1983/statistics_solidity/node_modules/@solidity-parser/parser/__scribble_ReentrancyUtils.sol";

struct UnitPoint {
    uint96 sumUnitDonationsETH;
    uint96 sumUnitTopUpsOLAS;
    uint32 numNewUnits;
    uint8 rewardUnitFraction;
    uint8 topUpUnitFraction;
    uint8 unitWeight;
}

struct EpochPoint {
    uint96 totalDonationsETH;
    uint96 totalTopUpsOLAS;
    uint64 idf;
    uint32 devsPerCapital;
    uint32 numNewOwners;
    uint32 endBlockNumber;
    uint32 endTime;
    uint8 rewardTreasuryFraction;
    uint8 maxBondFraction;
}

struct TokenomicsPoint {
    mapping(uint256 => UnitPoint) unitPoints;
    EpochPoint epochPoint;
}

struct IncentiveBalances {
    uint96 reward;
    uint96 pendingRelativeReward;
    uint96 topUp;
    uint96 pendingRelativeTopUp;
    uint32 lastEpoch;
}

/// @title Tokenomics - Smart contract for store/interface for key tokenomics params
///  @author AL
///  @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>
contract Tokenomics is __scribble_ReentrancyUtils, TokenomicsConstants, GenericTokenomics {
    using PRBMathSD59x18 for *;

    event EpochLengthUpdated(uint256 epochLength);

    event TokenomicsParametersUpdated(uint256 devsPerCapital, uint256 epsilonRate, uint256 epochLen, uint256 veOLASThreshold);

    event IncentiveFractionsUpdated(uint256 rewardComponentFraction, uint256 rewardAgentFraction, uint256 maxBondFraction, uint256 topUpComponentFraction, uint256 topUpAgentFraction);

    event ComponentRegistryUpdated(address indexed componentRegistry);

    event AgentRegistryUpdated(address indexed agentRegistry);

    event ServiceRegistryUpdated(address indexed serviceRegistry);

    event DonatorBlacklistUpdated(address indexed blacklist);

    event EpochSettled(uint256 indexed epochCounter, uint256 treasuryRewards, uint256 accountRewards, uint256 accountTopUps);

    event TokenomicsImplementationUpdated(address indexed implementation);

    struct vars2 {
        bool old_0;
        bool old_1;
        uint96 old_2;
        uint96 old_3;
        uint96 old_4;
        uint96 old_5;
        uint96 old_6;
        uint96 old_7;
    }

    struct vars3 {
        bool old_8;
        uint96 old_9;
        uint96 old_10;
        uint96 old_11;
        uint96 old_12;
        uint96 old_13;
        uint96 old_14;
    }

    struct vars4 {
        uint96 old_15;
        uint96 old_16;
    }

    struct vars5 {
        uint96 old_17;
    }

    struct vars6 {
        uint96 old_18;
        uint32 old_19;
    }

    struct vars7 {
        uint32 old_20;
        uint8 old_21;
        uint8 old_22;
    }

    address public ve;
    uint96 public maxBond;
    uint64 public epsilonRate;
    uint96 public inflationPerSecond;
    uint96 public veOLASThreshold;
    address public componentRegistry;
    uint96 public effectiveBond;
    uint32 public epochLen;
    uint32 public epochCounter;
    address public agentRegistry;
    uint8 public currentYear;
    uint8 public lockMaxBond;
    address public serviceRegistry;
    uint32 public timeLaunch;
    mapping(uint256 => uint256) public mapServiceAmounts;
    mapping(address => uint256) public mapOwnerRewards;
    mapping(address => uint256) public mapOwnerTopUps;
    mapping(uint256 => TokenomicsPoint) public mapEpochTokenomics;
    mapping(uint256 => mapping(uint256 => bool)) public mapNewUnits;
    mapping(address => bool) public mapNewOwners;
    mapping(uint256 => mapping(uint256 => IncentiveBalances)) public mapUnitIncentives;
    address public donatorBlacklist;

    /// @dev Tokenomics constructor.
    constructor() TokenomicsConstants() GenericTokenomics() {}

    function initializeTokenomics(address _olas, address _treasury, address _depository, address _dispenser, address _ve, uint32 _epochLen, address _componentRegistry, address _agentRegistry, address _serviceRegistry, address _donatorBlacklist) external {
        _original_Tokenomics_initializeTokenomics(_olas, _treasury, _depository, _dispenser, _ve, _epochLen, _componentRegistry, _agentRegistry, _serviceRegistry, _donatorBlacklist);
        unchecked {
            if (!(mapEpochTokenomics[0].epochPoint.endTime > 0)) {
                emit AssertionFailed("0: ep is correct endTime");
                assert(false);
            }
            if (!(effectiveBond == maxBond)) {
                emit AssertionFailed("1: maxBond eq effectiveBond form start");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_initializeTokenomics(address _olas, address _treasury, address _depository, address _dispenser, address _ve, uint32 _epochLen, address _componentRegistry, address _agentRegistry, address _serviceRegistry, address _donatorBlacklist) private {
        super.initialize(_olas, address(this), _treasury, _depository, _dispenser, TokenomicsRole.Tokenomics);
        epsilonRate = 1e17;
        veOLASThreshold = 5_000e18;
        lockMaxBond = 1;
        ve = _ve;
        epochLen = _epochLen;
        componentRegistry = _componentRegistry;
        agentRegistry = _agentRegistry;
        serviceRegistry = _serviceRegistry;
        donatorBlacklist = _donatorBlacklist;
        uint256 _timeLaunch = IOLAS(_olas).timeLaunch();
        if ((block.timestamp + 1) > (_timeLaunch + oneYear)) {
            revert Overflow(_timeLaunch + oneYear, block.timestamp);
        }
        uint256 zeroYearSecondsLeft = uint32((_timeLaunch + oneYear) - block.timestamp);
        uint256 _inflationPerSecond = 22_113_000_0e17 / zeroYearSecondsLeft;
        inflationPerSecond = uint96(_inflationPerSecond);
        timeLaunch = uint32(_timeLaunch);
        mapEpochTokenomics[0].epochPoint.endTime = uint32(block.timestamp);
        epochCounter = 1;
        TokenomicsPoint storage tp = mapEpochTokenomics[1];
        tp.epochPoint.devsPerCapital = 1;
        tp.epochPoint.idf = 1e18 + epsilonRate;
        tp.unitPoints[0].rewardUnitFraction = 66;
        tp.unitPoints[1].rewardUnitFraction = 34;
        tp.unitPoints[0].unitWeight = 1;
        tp.unitPoints[1].unitWeight = 2;
        uint256 _maxBondFraction = 49;
        tp.epochPoint.maxBondFraction = uint8(_maxBondFraction);
        tp.unitPoints[0].topUpUnitFraction = 34;
        tp.unitPoints[1].topUpUnitFraction = 17;
        uint256 _maxBond = ((_inflationPerSecond * _epochLen) * _maxBondFraction) / 100;
        maxBond = uint96(_maxBond);
        effectiveBond = uint96(_maxBond);
    }

    /// @dev Gets the tokenomics implementation contract address.
    ///  @return implementation Tokenomics implementation contract address.
    function tokenomicsImplementation() external view returns (address implementation) {
        assembly {
            implementation := sload(PROXY_TOKENOMICS)
        }
    }

    function changeTokenomicsImplementation(address implementation) external {
        _original_Tokenomics_changeTokenomicsImplementation(implementation);
        unchecked {
            if (!(implementation == this.tokenomicsImplementation())) {
                emit AssertionFailed("2: new implementation");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_changeTokenomicsImplementation(address implementation) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        assembly {
            sstore(PROXY_TOKENOMICS, implementation)
        }
        emit TokenomicsImplementationUpdated(implementation);
    }

    /// @dev Checks if the maxBond update is within allowed limits of the effectiveBond, and adjusts maxBond and effectiveBond.
    ///  @param nextMaxBond Proposed next epoch maxBond.
    function _adjustMaxBond(uint256 nextMaxBond) internal {
        uint256 curMaxBond = maxBond;
        uint256 curEffectiveBond = effectiveBond;
        if (curMaxBond > nextMaxBond) {
            uint256 delta = curMaxBond - nextMaxBond;
            if (curEffectiveBond > delta) {
                curEffectiveBond -= delta;
            } else {
                revert RejectMaxBondAdjustment(curEffectiveBond, delta);
            }
        } else {
            curEffectiveBond += nextMaxBond - curMaxBond;
        }
        maxBond = uint96(nextMaxBond);
        effectiveBond = uint96(curEffectiveBond);
    }

    function changeTokenomicsParameters(uint32 _devsPerCapital, uint64 _epsilonRate, uint32 _epochLen, uint96 _veOLASThreshold) external {
        vars2 memory _v;
        unchecked {
            _v.old_0 = (_epochLen > 0) && (epochLen != _epochLen);
            _v.old_1 = (_epochLen > 0) && (epochLen != _epochLen);
            _v.old_2 = maxBond;
            _v.old_3 = effectiveBond;
            _v.old_4 = maxBond;
            _v.old_5 = maxBond;
            _v.old_6 = effectiveBond;
            _v.old_7 = maxBond;
        }
        _original_Tokenomics_changeTokenomicsParameters(_devsPerCapital, _epsilonRate, _epochLen, _veOLASThreshold);
        unchecked {
            if (!((!(epochCounter >= 2)) || (mapEpochTokenomics[epochCounter - 1].epochPoint.endTime > mapEpochTokenomics[epochCounter - 2].epochPoint.endTime))) {
                emit AssertionFailed("3: ep is correct endTime");
                assert(false);
            }
            if (!(mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction > 0)) {
                emit AssertionFailed("4: ep is correct maxBondFraction");
                assert(false);
            }
            if (!((!_v.old_0) || (epochLen == _epochLen))) {
                emit AssertionFailed("5: epochLen");
                assert(false);
            }
            if (!((!(_devsPerCapital > 0)) || (mapEpochTokenomics[epochCounter].epochPoint.devsPerCapital == _devsPerCapital))) {
                emit AssertionFailed("6: devsPerCapital");
                assert(false);
            }
            if (!((!((_epsilonRate > 0) && (_epsilonRate < 17000000000000000000))) || (epsilonRate == _epsilonRate))) {
                emit AssertionFailed("7: epsilonRate");
                assert(false);
            }
            if (!((!_v.old_1) || (maxBond == (((inflationPerSecond * mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction) * _epochLen) / 100)))) {
                emit AssertionFailed("8: maxBond");
                assert(false);
            }
            if (!((!(_v.old_2 > maxBond)) || (effectiveBond == (_v.old_3 - (_v.old_4 - maxBond))))) {
                emit AssertionFailed("9: new effectiveBond with curMaxBond > nextMaxBond");
                assert(false);
            }
            if (!((!(maxBond > _v.old_5)) || (effectiveBond == (_v.old_6 + (maxBond - _v.old_7))))) {
                emit AssertionFailed("10: new effectiveBond with curMaxBond < nextMaxBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_changeTokenomicsParameters(uint32 _devsPerCapital, uint64 _epsilonRate, uint32 _epochLen, uint96 _veOLASThreshold) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if (_devsPerCapital > 0) {
            mapEpochTokenomics[epochCounter].epochPoint.devsPerCapital = _devsPerCapital;
        } else {
            _devsPerCapital = mapEpochTokenomics[epochCounter].epochPoint.devsPerCapital;
        }
        if ((_epsilonRate > 0) && (_epsilonRate < 17e18)) {
            epsilonRate = _epsilonRate;
        } else {
            _epsilonRate = epsilonRate;
        }
        uint256 oldEpochLen = epochLen;
        if ((_epochLen > 0) && (oldEpochLen != _epochLen)) {
            if (lockMaxBond == 2) {
                revert MaxBondUpdateLocked();
            }
            if (_epochLen > oldEpochLen) {
                uint256 lastEpochEndTime = mapEpochTokenomics[epochCounter - 1].epochPoint.endTime;
                uint256 numYears = ((lastEpochEndTime + _epochLen) - timeLaunch) / oneYear;
                if (numYears > currentYear) {
                    revert MaxBondUpdateLocked();
                }
            }
            uint256 nextMaxBond = ((inflationPerSecond * mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction) * _epochLen) / 100;
            _adjustMaxBond(nextMaxBond);
            epochLen = _epochLen;
        } else {
            _epochLen = epochLen;
        }
        if (_veOLASThreshold > 0) {
            veOLASThreshold = _veOLASThreshold;
        } else {
            _veOLASThreshold = veOLASThreshold;
        }
        emit TokenomicsParametersUpdated(_devsPerCapital, _epsilonRate, _epochLen, _veOLASThreshold);
    }

    function changeIncentiveFractions(uint8 _rewardComponentFraction, uint8 _rewardAgentFraction, uint8 _maxBondFraction, uint8 _topUpComponentFraction, uint8 _topUpAgentFraction) external {
        vars3 memory _v;
        unchecked {
            _v.old_8 = (_maxBondFraction > 0) && (mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction != _maxBondFraction);
            _v.old_9 = maxBond;
            _v.old_10 = effectiveBond;
            _v.old_11 = maxBond;
            _v.old_12 = maxBond;
            _v.old_13 = effectiveBond;
            _v.old_14 = maxBond;
        }
        _original_Tokenomics_changeIncentiveFractions(_rewardComponentFraction, _rewardAgentFraction, _maxBondFraction, _topUpComponentFraction, _topUpAgentFraction);
        unchecked {
            if (!((!(epochCounter >= 2)) || (mapEpochTokenomics[epochCounter - 1].epochPoint.endTime > mapEpochTokenomics[epochCounter - 2].epochPoint.endTime))) {
                emit AssertionFailed("11: ep is correct endTime");
                assert(false);
            }
            if (!(mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction > 0)) {
                emit AssertionFailed("12: ep is correct maxBondFraction");
                assert(false);
            }
            if (!((!_v.old_8) || (maxBond == (((inflationPerSecond * _maxBondFraction) * epochLen) / 100)))) {
                emit AssertionFailed("13: maxBond");
                assert(false);
            }
            if (!((!(_v.old_9 > maxBond)) || (effectiveBond == (_v.old_10 - (_v.old_11 - maxBond))))) {
                emit AssertionFailed("14: new effectiveBond with curMaxBond > nextMaxBond");
                assert(false);
            }
            if (!((!(maxBond > _v.old_12)) || (effectiveBond == (_v.old_13 + (maxBond - _v.old_14))))) {
                emit AssertionFailed("15: new effectiveBond with curMaxBond < nextMaxBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_changeIncentiveFractions(uint8 _rewardComponentFraction, uint8 _rewardAgentFraction, uint8 _maxBondFraction, uint8 _topUpComponentFraction, uint8 _topUpAgentFraction) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if ((_rewardComponentFraction + _rewardAgentFraction) > 100) {
            revert WrongAmount(_rewardComponentFraction + _rewardAgentFraction, 100);
        }
        if (((_maxBondFraction + _topUpComponentFraction) + _topUpAgentFraction) > 100) {
            revert WrongAmount((_maxBondFraction + _topUpComponentFraction) + _topUpAgentFraction, 100);
        }
        TokenomicsPoint storage tp = mapEpochTokenomics[epochCounter];
        tp.unitPoints[0].rewardUnitFraction = _rewardComponentFraction;
        tp.unitPoints[1].rewardUnitFraction = _rewardAgentFraction;
        tp.epochPoint.rewardTreasuryFraction = (100 - _rewardComponentFraction) - _rewardAgentFraction;
        uint256 oldMaxBondFraction = tp.epochPoint.maxBondFraction;
        if (oldMaxBondFraction != _maxBondFraction) {
            if (lockMaxBond == 2) {
                revert MaxBondUpdateLocked();
            }
            uint256 nextMaxBond = ((inflationPerSecond * _maxBondFraction) * epochLen) / 100;
            _adjustMaxBond(nextMaxBond);
            tp.epochPoint.maxBondFraction = _maxBondFraction;
        }
        tp.unitPoints[0].topUpUnitFraction = _topUpComponentFraction;
        tp.unitPoints[1].topUpUnitFraction = _topUpAgentFraction;
        emit IncentiveFractionsUpdated(_rewardComponentFraction, _rewardAgentFraction, _maxBondFraction, _topUpComponentFraction, _topUpAgentFraction);
    }

    /// @dev Changes registries contract addresses.
    ///  @param _componentRegistry Component registry address.
    ///  @param _agentRegistry Agent registry address.
    ///  @param _serviceRegistry Service registry address.
    function changeRegistries(address _componentRegistry, address _agentRegistry, address _serviceRegistry) external {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if (_componentRegistry != address(0)) {
            componentRegistry = _componentRegistry;
            emit ComponentRegistryUpdated(_componentRegistry);
        }
        if (_agentRegistry != address(0)) {
            agentRegistry = _agentRegistry;
            emit AgentRegistryUpdated(_agentRegistry);
        }
        if (_serviceRegistry != address(0)) {
            serviceRegistry = _serviceRegistry;
            emit ServiceRegistryUpdated(_serviceRegistry);
        }
    }

    /// @dev Changes donator blacklist contract address.
    ///  @notice DonatorBlacklist contract can be disabled by setting its address to zero.
    ///  @param _donatorBlacklist DonatorBlacklist contract address.
    function changeDonatorBlacklist(address _donatorBlacklist) external {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        donatorBlacklist = _donatorBlacklist;
        emit DonatorBlacklistUpdated(_donatorBlacklist);
    }

    function reserveAmountForBondProgram(uint256 amount) external returns (bool success) {
        vars4 memory _v;
        unchecked {
            _v.old_15 = effectiveBond;
            _v.old_16 = effectiveBond;
        }
        success = _original_Tokenomics_reserveAmountForBondProgram(amount);
        unchecked {
            if (!((!(_v.old_15 > amount)) || (effectiveBond == (_v.old_16 - amount)))) {
                emit AssertionFailed("16: effectiveBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_reserveAmountForBondProgram(uint256 amount) private returns (bool success) {
        if (depository != msg.sender) {
            revert ManagerOnly(msg.sender, depository);
        }
        uint256 eBond = effectiveBond;
        if ((eBond + 1) > amount) {
            eBond -= amount;
            effectiveBond = uint96(eBond);
            success = true;
        }
    }

    function refundFromBondProgram(uint256 amount) external {
        vars5 memory _v;
        unchecked {
            _v.old_17 = effectiveBond;
        }
        _original_Tokenomics_refundFromBondProgram(amount);
        unchecked {
            if (!(effectiveBond == (_v.old_17 + amount))) {
                emit AssertionFailed("17: effectiveBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_refundFromBondProgram(uint256 amount) private {
        if (depository != msg.sender) {
            revert ManagerOnly(msg.sender, depository);
        }
        uint256 eBond = effectiveBond + amount;
        effectiveBond = uint96(eBond);
    }

    /// @dev Finalizes epoch incentives for a specified component / agent Id.
    ///  @param epochNum Epoch number to finalize incentives for.
    ///  @param unitType Unit type (component / agent).
    ///  @param unitId Unit Id.
    function _finalizeIncentivesForUnitId(uint256 epochNum, uint256 unitType, uint256 unitId) internal {
        uint256 totalIncentives = mapUnitIncentives[unitType][unitId].pendingRelativeReward;
        if (totalIncentives > 0) {
            totalIncentives *= mapEpochTokenomics[epochNum].epochPoint.totalDonationsETH;
            totalIncentives *= mapEpochTokenomics[epochNum].unitPoints[unitType].rewardUnitFraction;
            uint256 sumUnitIncentives = mapEpochTokenomics[epochNum].unitPoints[unitType].sumUnitDonationsETH * 100;
            totalIncentives = mapUnitIncentives[unitType][unitId].reward + (totalIncentives / sumUnitIncentives);
            mapUnitIncentives[unitType][unitId].reward = uint96(totalIncentives);
            mapUnitIncentives[unitType][unitId].pendingRelativeReward = 0;
        }
        totalIncentives = mapUnitIncentives[unitType][unitId].pendingRelativeTopUp;
        if (totalIncentives > 0) {
            totalIncentives *= mapEpochTokenomics[epochNum].epochPoint.totalTopUpsOLAS;
            totalIncentives *= mapEpochTokenomics[epochNum].unitPoints[unitType].topUpUnitFraction;
            uint256 sumUnitIncentives = mapEpochTokenomics[epochNum].unitPoints[unitType].sumUnitTopUpsOLAS * 100;
            totalIncentives = mapUnitIncentives[unitType][unitId].topUp + (totalIncentives / sumUnitIncentives);
            mapUnitIncentives[unitType][unitId].topUp = uint96(totalIncentives);
            mapUnitIncentives[unitType][unitId].pendingRelativeTopUp = 0;
        }
    }

    /// @dev Records service donations into corresponding data structures.
    ///  @param serviceIds Set of service Ids.
    ///  @param amounts Correspondent set of ETH amounts provided by services.
    ///  @param curEpoch Current epoch number.
    function _trackServiceDonations(uint256[] memory serviceIds, uint256[] memory amounts, uint256 curEpoch) internal {
        address[] memory registries = new address[](2);
        (registries[0], registries[1]) = (componentRegistry, agentRegistry);
        bool[] memory incentiveFlags = new bool[](4);
        incentiveFlags[0] = (mapEpochTokenomics[curEpoch].unitPoints[0].rewardUnitFraction > 0);
        incentiveFlags[1] = (mapEpochTokenomics[curEpoch].unitPoints[1].rewardUnitFraction > 0);
        incentiveFlags[2] = (mapEpochTokenomics[curEpoch].unitPoints[0].topUpUnitFraction > 0);
        incentiveFlags[3] = (mapEpochTokenomics[curEpoch].unitPoints[1].topUpUnitFraction > 0);
        uint256 numServices = serviceIds.length;
        for (uint256 i = 0; i < numServices; ++i) {
            uint96 amount = uint96(amounts[i]);
            bool topUpEligible;
            if (incentiveFlags[2] || incentiveFlags[3]) {
                address serviceOwner = IToken(serviceRegistry).ownerOf(serviceIds[i]);
                topUpEligible = (IVotingEscrow(ve).getVotes(serviceOwner) > veOLASThreshold) ? true : false;
            }
            for (uint256 unitType = 0; unitType < 2; ++unitType) {
                (uint256 numServiceUnits, uint32[] memory serviceUnitIds) = IServiceTokenomics(serviceRegistry).getUnitIdsOfService(IServiceTokenomics.UnitType(unitType), serviceIds[i]);
                if (incentiveFlags[unitType] || incentiveFlags[unitType + 2]) {
                    for (uint256 j = 0; j < numServiceUnits; ++j) {
                        uint256 lastEpoch = mapUnitIncentives[unitType][serviceUnitIds[j]].lastEpoch;
                        if (lastEpoch == 0) {
                            mapUnitIncentives[unitType][serviceUnitIds[j]].lastEpoch = uint32(curEpoch);
                        } else if (lastEpoch < curEpoch) {
                            _finalizeIncentivesForUnitId(lastEpoch, unitType, serviceUnitIds[j]);
                            mapUnitIncentives[unitType][serviceUnitIds[j]].lastEpoch = uint32(curEpoch);
                        }
                        if (incentiveFlags[unitType]) {
                            mapUnitIncentives[unitType][serviceUnitIds[j]].pendingRelativeReward += amount;
                            mapEpochTokenomics[curEpoch].unitPoints[unitType].sumUnitDonationsETH += amount;
                        }
                        if (topUpEligible && incentiveFlags[unitType + 2]) {
                            mapUnitIncentives[unitType][serviceUnitIds[j]].pendingRelativeTopUp += amount;
                            mapEpochTokenomics[curEpoch].unitPoints[unitType].sumUnitTopUpsOLAS += amount;
                        }
                    }
                }
                for (uint256 j = 0; j < numServiceUnits; ++j) {
                    if (!mapNewUnits[unitType][serviceUnitIds[j]]) {
                        mapNewUnits[unitType][serviceUnitIds[j]] = true;
                        mapEpochTokenomics[curEpoch].unitPoints[unitType].numNewUnits++;
                        address unitOwner = IToken(registries[unitType]).ownerOf(serviceUnitIds[j]);
                        if (!mapNewOwners[unitOwner]) {
                            mapNewOwners[unitOwner] = true;
                            mapEpochTokenomics[curEpoch].epochPoint.numNewOwners++;
                        }
                    }
                }
            }
        }
    }

    function trackServiceDonations(address donator, uint256[] memory serviceIds, uint256[] memory amounts) external returns (uint256 donationETH) {
        vars6 memory _v;
        unchecked {
            _v.old_18 = mapEpochTokenomics[epochCounter].epochPoint.totalDonationsETH;
            _v.old_19 = mapEpochTokenomics[epochCounter].epochPoint.numNewOwners;
        }
        donationETH = _original_Tokenomics_trackServiceDonations(donator, serviceIds, amounts);
        unchecked {
            if (!(mapEpochTokenomics[epochCounter].epochPoint.totalDonationsETH == (_v.old_18 + arr_sum_funs.sum_arr_uint256_arr_memory(amounts)))) {
                emit AssertionFailed("18: totalDonationsETH can only increase");
                assert(false);
            }
            if (!(mapEpochTokenomics[epochCounter].epochPoint.numNewOwners >= _v.old_19)) {
                emit AssertionFailed("19: numNewOwners can only increase");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_trackServiceDonations(address donator, uint256[] memory serviceIds, uint256[] memory amounts) private returns (uint256 donationETH) {
        if (treasury != msg.sender) {
            revert ManagerOnly(msg.sender, treasury);
        }
        address bList = donatorBlacklist;
        if ((bList != address(0)) && IDonatorBlacklist(bList).isDonatorBlacklisted(donator)) {
            revert DonatorBlacklisted(donator);
        }
        uint256 numServices = serviceIds.length;
        for (uint256 i = 0; i < numServices; ++i) {
            if (!IServiceTokenomics(serviceRegistry).exists(serviceIds[i])) {
                revert ServiceDoesNotExist(serviceIds[i]);
            }
            donationETH += amounts[i];
        }
        uint256 curEpoch = epochCounter;
        donationETH = mapEpochTokenomics[curEpoch].epochPoint.totalDonationsETH + donationETH;
        mapEpochTokenomics[curEpoch].epochPoint.totalDonationsETH = uint96(donationETH);
        _trackServiceDonations(serviceIds, amounts, curEpoch);
    }

    function checkpoint() external returns (bool RET_0) {
        vars7 memory _v;
        unchecked {
            _v.old_20 = epochCounter;
            _v.old_21 = currentYear;
            _v.old_22 = currentYear;
        }
        RET_0 = _original_Tokenomics_checkpoint();
        unchecked {
            if (!((!(RET_0 == true)) || (epochCounter == (_v.old_20 + 1)))) {
                emit AssertionFailed("20: epochCounter can only increase");
                assert(false);
            }
            if (!((!((RET_0 == true) && (((block.timestamp - timeLaunch) / oneYear) > _v.old_21))) || (currentYear == (_v.old_22 + 1)))) {
                emit AssertionFailed("21: two events will never happen at the same time");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_checkpoint() private returns (bool) {
        address implementation;
        assembly {
            implementation := sload(PROXY_TOKENOMICS)
        }
        if (implementation == address(0)) {
            revert DelegatecallOnly();
        }
        uint256 prevEpochTime = mapEpochTokenomics[epochCounter - 1].epochPoint.endTime;
        uint256 diffNumSeconds = block.timestamp - prevEpochTime;
        uint256 curEpochLen = epochLen;
        if (diffNumSeconds < curEpochLen) {
            return false;
        }
        uint256 eCounter = epochCounter;
        TokenomicsPoint storage tp = mapEpochTokenomics[eCounter];
        uint256[] memory incentives = new uint256[](7);
        incentives[0] = tp.epochPoint.totalDonationsETH;
        incentives[1] = (incentives[0] * tp.epochPoint.rewardTreasuryFraction) / 100;
        incentives[2] = (incentives[0] * tp.unitPoints[0].rewardUnitFraction) / 100;
        incentives[3] = (incentives[0] * tp.unitPoints[1].rewardUnitFraction) / 100;
        uint256 inflationPerEpoch;
        uint256 curMaxBond = maxBond;
        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;
        if (numYears > currentYear) {
            uint256 curInflationPerSecond = inflationPerSecond;
            uint256 yearEndTime = timeLaunch + (numYears * oneYear);
            inflationPerEpoch = (yearEndTime - prevEpochTime) * curInflationPerSecond;
            curInflationPerSecond = getInflationForYear(numYears) / oneYear;
            inflationPerEpoch += (block.timestamp - yearEndTime) * curInflationPerSecond;
            maxBond = uint96((curInflationPerSecond * curEpochLen) * tp.epochPoint.maxBondFraction) / 100;
            inflationPerSecond = uint96(curInflationPerSecond);
            currentYear = uint8(numYears);
            lockMaxBond = 1;
        } else {
            inflationPerEpoch = inflationPerSecond * diffNumSeconds;
        }
        tp.epochPoint.totalTopUpsOLAS = uint96(inflationPerEpoch);
        incentives[4] = (inflationPerEpoch * tp.epochPoint.maxBondFraction) / 100;
        if (incentives[4] > curMaxBond) {
            incentives[4] = (effectiveBond + incentives[4]) - curMaxBond;
            effectiveBond = uint96(incentives[4]);
        }
        numYears = ((block.timestamp + curEpochLen) - timeLaunch) / oneYear;
        if (numYears > currentYear) {
            uint256 curInflationPerSecond = inflationPerSecond;
            uint256 yearEndTime = timeLaunch + (numYears * oneYear);
            curMaxBond = (((yearEndTime - block.timestamp) * curInflationPerSecond) * tp.epochPoint.maxBondFraction) / 100;
            curInflationPerSecond = getInflationForYear(numYears) / oneYear;
            curMaxBond += ((((block.timestamp + curEpochLen) - yearEndTime) * curInflationPerSecond) * tp.epochPoint.maxBondFraction) / 100;
            maxBond = uint96(curMaxBond);
            lockMaxBond = 2;
        } else {
            curMaxBond = maxBond;
        }
        curMaxBond += effectiveBond;
        effectiveBond = uint96(curMaxBond);
        uint64 idf;
        if (incentives[0] > 0) {
            uint256 sumWeights = tp.unitPoints[0].unitWeight * tp.unitPoints[1].unitWeight;
            uint256 codeUnits = ((tp.unitPoints[1].unitWeight * tp.unitPoints[0].numNewUnits) + (tp.unitPoints[0].unitWeight * tp.unitPoints[1].numNewUnits)) / sumWeights;
            int256 fp1 = PRBMathSD59x18.fromInt(int256(incentives[1])) / 1e18;
            int256 fp2 = PRBMathSD59x18.fromInt(int256(codeUnits * tp.epochPoint.devsPerCapital));
            fp1 = fp1.mul(fp2);
            fp2 = PRBMathSD59x18.fromInt(int256(codeUnits * tp.epochPoint.numNewOwners));
            int256 fp = fp1 + fp2;
            fp = fp.div(PRBMathSD59x18.fromInt(100));
            uint256 fKD = uint256(fp);
            if (fKD > epsilonRate) {
                fKD = epsilonRate;
            }
            idf = uint64(1e18 + fKD);
        }
        tp.epochPoint.endBlockNumber = uint32(block.number);
        tp.epochPoint.endTime = uint32(block.timestamp);
        uint256 accountRewards = incentives[2] + incentives[3];
        incentives[5] = (inflationPerEpoch * tp.unitPoints[0].topUpUnitFraction) / 100;
        incentives[6] = (inflationPerEpoch * tp.unitPoints[1].topUpUnitFraction) / 100;
        uint256 accountTopUps = incentives[5] + incentives[6];
        if ((incentives[1] == 0) || ITreasury(treasury).rebalanceTreasury(incentives[1])) {
            emit EpochSettled(eCounter, incentives[1], accountRewards, accountTopUps);
            eCounter++;
            epochCounter = uint32(eCounter);
        } else {
            revert TreasuryRebalanceFailed(eCounter);
        }
        TokenomicsPoint storage nextPoint = mapEpochTokenomics[eCounter];
        for (uint256 i = 0; i < 2; ++i) {
            nextPoint.unitPoints[i].topUpUnitFraction = tp.unitPoints[i].topUpUnitFraction;
            nextPoint.unitPoints[i].rewardUnitFraction = tp.unitPoints[i].rewardUnitFraction;
            nextPoint.unitPoints[i].unitWeight = tp.unitPoints[i].unitWeight;
        }
        nextPoint.epochPoint.rewardTreasuryFraction = tp.epochPoint.rewardTreasuryFraction;
        nextPoint.epochPoint.maxBondFraction = tp.epochPoint.maxBondFraction;
        nextPoint.epochPoint.devsPerCapital = tp.epochPoint.devsPerCapital;
        nextPoint.epochPoint.idf = idf;
        return true;
    }

    /// @dev Gets inflation per last epoch.
    ///  @return inflationPerEpoch Inflation value.
    function getInflationPerEpoch() external view returns (uint256 inflationPerEpoch) {
        inflationPerEpoch = inflationPerSecond * epochLen;
    }

    /// @dev Gets epoch point of a specified epoch number.
    ///  @param epoch Epoch number.
    ///  @return ep Epoch point.
    function getEpochPoint(uint256 epoch) external view returns (EpochPoint memory ep) {
        ep = mapEpochTokenomics[epoch].epochPoint;
    }

    /// @dev Gets component / agent point of a specified epoch number and a unit type.
    ///  @param epoch Epoch number.
    ///  @param unitType Component (0) or agent (1).
    ///  @return up Unit point.
    function getUnitPoint(uint256 epoch, uint256 unitType) external view returns (UnitPoint memory up) {
        up = mapEpochTokenomics[epoch].unitPoints[unitType];
    }

    /// @dev Gets inverse discount factor with the multiple of 1e18.
    ///  @param epoch Epoch number.
    ///  @return idf Discount factor with the multiple of 1e18.
    function getIDF(uint256 epoch) external view returns (uint256 idf) {
        idf = mapEpochTokenomics[epoch].epochPoint.idf;
        if (idf == 0) {
            idf = 1e18;
        }
    }

    /// @dev Gets inverse discount factor with the multiple of 1e18 of the last epoch.
    ///  @return idf Discount factor with the multiple of 1e18.
    function getLastIDF() external view returns (uint256 idf) {
        idf = mapEpochTokenomics[epochCounter - 1].epochPoint.idf;
        if (idf == 0) {
            idf = 1e18;
        }
    }

    /// @dev Gets component / agent owner incentives and clears the balances.
    ///  @notice `account` must be the owner of components / agents they are passing, otherwise the function will revert.
    ///  @notice If not all `unitIds` belonging to `account` were provided, they will be untouched and keep accumulating.
    ///  @notice Component and agent Ids must be provided in the ascending order and must not repeat.
    ///  @param account Account address.
    ///  @param unitTypes Set of unit types (component / agent).
    ///  @param unitIds Set of corresponding unit Ids where account is the owner.
    ///  @return reward Reward amount.
    ///  @return topUp Top-up amount.
    function accountOwnerIncentives(address account, uint256[] memory unitTypes, uint256[] memory unitIds) external returns (uint256 reward, uint256 topUp) {
        if (dispenser != msg.sender) {
            revert ManagerOnly(msg.sender, dispenser);
        }
        if (unitTypes.length != unitIds.length) {
            revert WrongArrayLength(unitTypes.length, unitIds.length);
        }
        address[] memory registries = new address[](2);
        (registries[0], registries[1]) = (componentRegistry, agentRegistry);
        uint256[] memory lastIds = new uint256[](2);
        for (uint256 i = 0; i < unitIds.length; ++i) {
            if (unitTypes[i] > 1) {
                revert Overflow(unitTypes[i], 1);
            }
            address unitOwner = IToken(registries[unitTypes[i]]).ownerOf(unitIds[i]);
            if (unitOwner != account) {
                revert OwnerOnly(unitOwner, account);
            }
            if ((lastIds[unitTypes[i]] + 1) > unitIds[i]) {
                revert WrongUnitId(unitIds[i], unitTypes[i]);
            }
            lastIds[unitTypes[i]] = unitIds[i];
        }
        uint256 curEpoch = epochCounter;
        for (uint256 i = 0; i < unitIds.length; ++i) {
            uint256 lastEpoch = mapUnitIncentives[unitTypes[i]][unitIds[i]].lastEpoch;
            if ((lastEpoch > 0) && (lastEpoch < curEpoch)) {
                _finalizeIncentivesForUnitId(lastEpoch, unitTypes[i], unitIds[i]);
                mapUnitIncentives[unitTypes[i]][unitIds[i]].lastEpoch = 0;
            }
            reward += mapUnitIncentives[unitTypes[i]][unitIds[i]].reward;
            mapUnitIncentives[unitTypes[i]][unitIds[i]].reward = 0;
            topUp += mapUnitIncentives[unitTypes[i]][unitIds[i]].topUp;
            mapUnitIncentives[unitTypes[i]][unitIds[i]].topUp = 0;
        }
    }

    /// @dev Gets the component / agent owner incentives.
    ///  @notice `account` must be the owner of components / agents they are passing, otherwise the function will revert.
    ///  @param account Account address.
    ///  @param unitTypes Set of unit types (component / agent).
    ///  @param unitIds Set of corresponding unit Ids where account is the owner.
    ///  @return reward Reward amount.
    ///  @return topUp Top-up amount.
    function getOwnerIncentives(address account, uint256[] memory unitTypes, uint256[] memory unitIds) external view returns (uint256 reward, uint256 topUp) {
        if (unitTypes.length != unitIds.length) {
            revert WrongArrayLength(unitTypes.length, unitIds.length);
        }
        address[] memory registries = new address[](2);
        (registries[0], registries[1]) = (componentRegistry, agentRegistry);
        uint256[] memory lastIds = new uint256[](2);
        for (uint256 i = 0; i < unitIds.length; ++i) {
            if (unitTypes[i] > 1) {
                revert Overflow(unitTypes[i], 1);
            }
            address unitOwner = IToken(registries[unitTypes[i]]).ownerOf(unitIds[i]);
            if (unitOwner != account) {
                revert OwnerOnly(unitOwner, account);
            }
            if ((lastIds[unitTypes[i]] + 1) > unitIds[i]) {
                revert WrongUnitId(unitIds[i], unitTypes[i]);
            }
            lastIds[unitTypes[i]] = unitIds[i];
        }
        uint256 curEpoch = epochCounter;
        for (uint256 i = 0; i < unitIds.length; ++i) {
            uint256 lastEpoch = mapUnitIncentives[unitTypes[i]][unitIds[i]].lastEpoch;
            if ((lastEpoch > 0) && (lastEpoch < curEpoch)) {
                uint256 totalIncentives = mapUnitIncentives[unitTypes[i]][unitIds[i]].pendingRelativeReward;
                if (totalIncentives > 0) {
                    totalIncentives *= mapEpochTokenomics[lastEpoch].epochPoint.totalDonationsETH;
                    totalIncentives *= mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].rewardUnitFraction;
                    uint256 sumUnitIncentives = mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].sumUnitDonationsETH * 100;
                    reward += totalIncentives / sumUnitIncentives;
                }
                totalIncentives = mapUnitIncentives[unitTypes[i]][unitIds[i]].pendingRelativeTopUp;
                if (totalIncentives > 0) {
                    totalIncentives *= mapEpochTokenomics[lastEpoch].epochPoint.totalTopUpsOLAS;
                    totalIncentives *= mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].topUpUnitFraction;
                    uint256 sumUnitIncentives = mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].sumUnitTopUpsOLAS * 100;
                    topUp += totalIncentives / sumUnitIncentives;
                }
            }
            reward += mapUnitIncentives[unitTypes[i]][unitIds[i]].reward;
            topUp += mapUnitIncentives[unitTypes[i]][unitIds[i]].topUp;
        }
    }

    /// @dev Gets incentive balances of a component / agent.
    ///  @notice Note that these numbers are not final values per epoch, since more donations might be given
    ///          and incentive fractions are subject to change by the governance.
    ///  @param unitType Unit type (component or agent).
    ///  @param unitId Unit Id.
    ///  @return Component / agent incentive balances.
    function getIncentiveBalances(uint256 unitType, uint256 unitId) external view returns (IncentiveBalances memory) {
        return mapUnitIncentives[unitType][unitId];
    }
}