/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity ^0.8.17;

import "./TokenomicsConstants.sol";
import "./interfaces/IDonatorBlacklist.sol";
import "./interfaces/IErrorsTokenomics.sol";
import "./interfaces/IOLAS.sol";
import "./interfaces/IServiceRegistry.sol";
import "./interfaces/IToken.sol";
import "./interfaces/ITreasury.sol";
import "./interfaces/IVotingEscrow.sol";
import "@prb/math/__scribble_ReentrancyUtils.sol";

struct UnitPoint {
    uint96 sumUnitDonationsETH;
    uint96 sumUnitTopUpsOLAS;
    uint32 numNewUnits;
    uint8 rewardUnitFraction;
    uint8 topUpUnitFraction;
    uint8 unitWeight;
}

struct EpochPoint {
    uint96 totalDonationsETH;
    uint96 totalTopUpsOLAS;
    uint64 idf;
    uint32 devsPerCapital;
    uint32 numNewOwners;
    uint32 endTime;
    uint8 rewardTreasuryFraction;
    uint8 maxBondFraction;
}

struct TokenomicsPoint {
    mapping(uint256 => UnitPoint) unitPoints;
    EpochPoint epochPoint;
}

struct IncentiveBalances {
    uint96 reward;
    uint96 pendingRelativeReward;
    uint96 topUp;
    uint96 pendingRelativeTopUp;
    uint32 lastEpoch;
}

/// @title Tokenomics - Smart contract for store/interface for key tokenomics params
///  @author AL
///  @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>
contract Tokenomics is __scribble_ReentrancyUtils, TokenomicsConstants, IErrorsTokenomics {
    event OwnerUpdated(address indexed owner);

    event TreasuryUpdated(address indexed treasury);

    event DepositoryUpdated(address indexed depository);

    event DispenserUpdated(address indexed dispenser);

    event EpochLengthUpdated(uint256 epochLen);

    event EffectiveBondUpdated(uint256 effectiveBond);

    event TokenomicsParametersUpdated(uint256 devsPerCapital, uint256 epsilonRate, uint256 epochLen, uint256 veOLASThreshold);

    event IncentiveFractionsUpdated(uint256 rewardComponentFraction, uint256 rewardAgentFraction, uint256 maxBondFraction, uint256 topUpComponentFraction, uint256 topUpAgentFraction);

    event ComponentRegistryUpdated(address indexed componentRegistry);

    event AgentRegistryUpdated(address indexed agentRegistry);

    event ServiceRegistryUpdated(address indexed serviceRegistry);

    event DonatorBlacklistUpdated(address indexed blacklist);

    event EpochSettled(uint256 indexed epochCounter, uint256 treasuryRewards, uint256 accountRewards, uint256 accountTopUps);

    event TokenomicsImplementationUpdated(address indexed implementation);

    struct vars0 {
        address old_0;
        address old_1;
        address old_2;
        address old_3;
        address old_4;
        bool old_5;
        address old_6;
        address old_7;
        address old_8;
        bool old_9;
    }

    struct vars2 {
        bool old_10;
        bool old_11;
        uint96 old_12;
        uint96 old_13;
        uint96 old_14;
        uint96 old_15;
        uint96 old_16;
        uint96 old_17;
    }

    struct vars3 {
        bool old_18;
        uint96 old_19;
        uint96 old_20;
        uint96 old_21;
        uint96 old_22;
        uint96 old_23;
        uint96 old_24;
    }

    struct vars4 {
        uint96 old_25;
        uint96 old_26;
    }

    struct vars5 {
        uint256 old_27;
        uint96 old_28;
    }

    struct vars6 {
        uint96 old_29;
        uint96 old_30;
        uint32 old_31;
    }

    struct vars7 {
        uint32 old_32;
        uint8 old_33;
        uint8 old_34;
    }

    address public owner;
    uint96 public maxBond;
    address public olas;
    uint96 public inflationPerSecond;
    address public treasury;
    uint96 public veOLASThreshold;
    address public depository;
    uint96 public effectiveBond;
    address public dispenser;
    uint64 public epsilonRate;
    uint32 public epochLen;
    address public ve;
    uint32 public epochCounter;
    uint32 public timeLaunch;
    uint8 public currentYear;
    uint8 public lockMaxBond;
    uint8 internal _locked;
    address public componentRegistry;
    address public agentRegistry;
    address public serviceRegistry;
    mapping(uint256 => uint256) public mapServiceAmounts;
    mapping(address => uint256) public mapOwnerRewards;
    mapping(address => uint256) public mapOwnerTopUps;
    mapping(uint256 => TokenomicsPoint) public mapEpochTokenomics;
    mapping(uint256 => mapping(uint256 => bool)) public mapNewUnits;
    mapping(address => bool) public mapNewOwners;
    mapping(uint256 => mapping(uint256 => IncentiveBalances)) public mapUnitIncentives;
    address public donatorBlacklist;

    /// @dev Tokenomics constructor.
    constructor() TokenomicsConstants() {}

    function initializeTokenomics(address _olas, address _treasury, address _depository, address _dispenser, address _ve, uint256 _epochLen, address _componentRegistry, address _agentRegistry, address _serviceRegistry, address _donatorBlacklist) external {
        vars0 memory _v;
        unchecked {
            _v.old_0 = _olas;
            _v.old_1 = _treasury;
            _v.old_2 = _depository;
            _v.old_3 = _dispenser;
            _v.old_4 = _ve;
            _v.old_5 = (_epochLen > MIN_EPOCH_LENGTH) && (_epochLen < type(uint32).max);
            _v.old_6 = _componentRegistry;
            _v.old_7 = _agentRegistry;
            _v.old_8 = _serviceRegistry;
            _v.old_9 = (((_epochLen > MIN_EPOCH_LENGTH) && (_epochLen < type(uint32).max)) && (inflationPerSecond > 0)) && (inflationPerSecond <= getInflationForYear(0));
        }
        _original_Tokenomics_initializeTokenomics(_olas, _treasury, _depository, _dispenser, _ve, _epochLen, _componentRegistry, _agentRegistry, _serviceRegistry, _donatorBlacklist);
        unchecked {
            if (!(mapEpochTokenomics[0].epochPoint.endTime > 0)) {
                emit AssertionFailed("0: ep is correct endTime");
                assert(false);
            }
            if (!(effectiveBond == maxBond)) {
                emit AssertionFailed("1: maxBond eq effectiveBond form start");
                assert(false);
            }
            if (!((!(_v.old_0 != address(0))) || (olas == _olas))) {
                emit AssertionFailed("2: olas must not be a zero address");
                assert(false);
            }
            if (!((!(_v.old_1 != address(0))) || (treasury == _treasury))) {
                emit AssertionFailed("3: treasury must not be a zero address");
                assert(false);
            }
            if (!((!(_v.old_2 != address(0))) || (depository == _depository))) {
                emit AssertionFailed("4: depository must not be a zero address");
                assert(false);
            }
            if (!((!(_v.old_3 != address(0))) || (dispenser == _dispenser))) {
                emit AssertionFailed("5: dispenser must not be a zero address");
                assert(false);
            }
            if (!((!(_v.old_4 != address(0))) || (ve == _ve))) {
                emit AssertionFailed("6: vaOLAS must not be a zero address");
                assert(false);
            }
            if (!((!_v.old_5) || (epochLen == _epochLen))) {
                emit AssertionFailed("7: epochLen");
                assert(false);
            }
            if (!((!(_v.old_6 != address(0))) || (componentRegistry == _componentRegistry))) {
                emit AssertionFailed("8: componentRegistry must not be a zero address");
                assert(false);
            }
            if (!((!(_v.old_7 != address(0))) || (agentRegistry == _agentRegistry))) {
                emit AssertionFailed("9: agentRegistry must not be a zero address");
                assert(false);
            }
            if (!((!(_v.old_8 != address(0))) || (serviceRegistry == _serviceRegistry))) {
                emit AssertionFailed("10: serviceRegistry must not be a zero address");
                assert(false);
            }
            if (!(donatorBlacklist == _donatorBlacklist)) {
                emit AssertionFailed("11: donatorBlacklist assignment");
                assert(false);
            }
            if (!((inflationPerSecond > 0) && (inflationPerSecond <= getInflationForYear(0)))) {
                emit AssertionFailed("12: inflationPerSecond must not be zero");
                assert(false);
            }
            if (!(mapEpochTokenomics[0].epochPoint.endTime > 0)) {
                emit AssertionFailed("13: Zero epoch point end time must be non-zero");
                assert(false);
            }
            if (!((!_v.old_9) || (maxBond == (((inflationPerSecond * _epochLen) * mapEpochTokenomics[1].epochPoint.maxBondFraction) / 100)))) {
                emit AssertionFailed("14: maxBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_initializeTokenomics(address _olas, address _treasury, address _depository, address _dispenser, address _ve, uint256 _epochLen, address _componentRegistry, address _agentRegistry, address _serviceRegistry, address _donatorBlacklist) private {
        if (owner != address(0)) {
            revert AlreadyInitialized();
        }
        if ((((((((_olas == address(0)) || (_treasury == address(0))) || (_depository == address(0))) || (_dispenser == address(0))) || (_ve == address(0))) || (_componentRegistry == address(0))) || (_agentRegistry == address(0))) || (_serviceRegistry == address(0))) {
            revert ZeroAddress();
        }
        owner = msg.sender;
        _locked = 1;
        epsilonRate = 1e17;
        veOLASThreshold = 5_000e18;
        lockMaxBond = 1;
        if (_epochLen < MIN_EPOCH_LENGTH) {
            revert AmountLowerThan(_epochLen, MIN_EPOCH_LENGTH);
        }
        olas = _olas;
        treasury = _treasury;
        depository = _depository;
        dispenser = _dispenser;
        ve = _ve;
        epochLen = uint32(_epochLen);
        componentRegistry = _componentRegistry;
        agentRegistry = _agentRegistry;
        serviceRegistry = _serviceRegistry;
        donatorBlacklist = _donatorBlacklist;
        uint256 _timeLaunch = IOLAS(_olas).timeLaunch();
        if ((block.timestamp + 1) > (_timeLaunch + ONE_YEAR)) {
            revert Overflow(_timeLaunch + ONE_YEAR, block.timestamp);
        }
        uint256 zeroYearSecondsLeft = uint32((_timeLaunch + ONE_YEAR) - block.timestamp);
        uint256 _inflationPerSecond = getInflationForYear(0) / zeroYearSecondsLeft;
        inflationPerSecond = uint96(_inflationPerSecond);
        timeLaunch = uint32(_timeLaunch);
        mapEpochTokenomics[0].epochPoint.endTime = uint32(block.timestamp);
        epochCounter = 1;
        TokenomicsPoint storage tp = mapEpochTokenomics[1];
        tp.epochPoint.devsPerCapital = 1;
        tp.epochPoint.idf = 1e18 + epsilonRate;
        tp.unitPoints[0].rewardUnitFraction = 66;
        tp.unitPoints[1].rewardUnitFraction = 34;
        tp.unitPoints[0].unitWeight = 1;
        tp.unitPoints[1].unitWeight = 2;
        uint256 _maxBondFraction = 49;
        tp.epochPoint.maxBondFraction = uint8(_maxBondFraction);
        tp.unitPoints[0].topUpUnitFraction = 34;
        tp.unitPoints[1].topUpUnitFraction = 17;
        uint256 _maxBond = ((_inflationPerSecond * _epochLen) * _maxBondFraction) / 100;
        maxBond = uint96(_maxBond);
        effectiveBond = uint96(_maxBond);
    }

    /// @dev Gets the tokenomics implementation contract address.
    ///  @return implementation Tokenomics implementation contract address.
    function tokenomicsImplementation() external view returns (address implementation) {
        assembly {
            implementation := sload(PROXY_TOKENOMICS)
        }
    }

    function changeTokenomicsImplementation(address implementation) external {
        _original_Tokenomics_changeTokenomicsImplementation(implementation);
        unchecked {
            if (!(implementation == this.tokenomicsImplementation())) {
                emit AssertionFailed("15: new implementation");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_changeTokenomicsImplementation(address implementation) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        assembly {
            sstore(PROXY_TOKENOMICS, implementation)
        }
        emit TokenomicsImplementationUpdated(implementation);
    }

    /// @dev Changes the owner address.
    ///  @param newOwner Address of a new owner.
    function changeOwner(address newOwner) external {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if (newOwner == address(0)) {
            revert ZeroAddress();
        }
        owner = newOwner;
        emit OwnerUpdated(newOwner);
    }

    /// @dev Changes various managing contract addresses.
    ///  @param _treasury Treasury address.
    ///  @param _depository Depository address.
    ///  @param _dispenser Dispenser address.
    function changeManagers(address _treasury, address _depository, address _dispenser) external {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if (_treasury != address(0)) {
            treasury = _treasury;
            emit TreasuryUpdated(_treasury);
        }
        if (_depository != address(0)) {
            depository = _depository;
            emit DepositoryUpdated(_depository);
        }
        if (_dispenser != address(0)) {
            dispenser = _dispenser;
            emit DispenserUpdated(_dispenser);
        }
    }

    /// @dev Changes registries contract addresses.
    ///  @param _componentRegistry Component registry address.
    ///  @param _agentRegistry Agent registry address.
    ///  @param _serviceRegistry Service registry address.
    function changeRegistries(address _componentRegistry, address _agentRegistry, address _serviceRegistry) external {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if (_componentRegistry != address(0)) {
            componentRegistry = _componentRegistry;
            emit ComponentRegistryUpdated(_componentRegistry);
        }
        if (_agentRegistry != address(0)) {
            agentRegistry = _agentRegistry;
            emit AgentRegistryUpdated(_agentRegistry);
        }
        if (_serviceRegistry != address(0)) {
            serviceRegistry = _serviceRegistry;
            emit ServiceRegistryUpdated(_serviceRegistry);
        }
    }

    /// @dev Changes donator blacklist contract address.
    ///  @notice DonatorBlacklist contract can be disabled by setting its address to zero.
    ///  @param _donatorBlacklist DonatorBlacklist contract address.
    function changeDonatorBlacklist(address _donatorBlacklist) external {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        donatorBlacklist = _donatorBlacklist;
        emit DonatorBlacklistUpdated(_donatorBlacklist);
    }

    /// @dev Checks if the maxBond update is within allowed limits of the effectiveBond, and adjusts maxBond and effectiveBond.
    ///  @param nextMaxBond Proposed next epoch maxBond.
    function _adjustMaxBond(uint256 nextMaxBond) internal {
        uint256 curMaxBond = maxBond;
        uint256 curEffectiveBond = effectiveBond;
        if (curMaxBond > nextMaxBond) {
            uint256 delta = curMaxBond - nextMaxBond;
            if (curEffectiveBond > delta) {
                curEffectiveBond -= delta;
            } else {
                revert RejectMaxBondAdjustment(curEffectiveBond, delta);
            }
        } else {
            curEffectiveBond += nextMaxBond - curMaxBond;
        }
        maxBond = uint96(nextMaxBond);
        effectiveBond = uint96(curEffectiveBond);
    }

    function changeTokenomicsParameters(uint256 _devsPerCapital, uint256 _epsilonRate, uint256 _epochLen, uint256 _veOLASThreshold) external {
        vars2 memory _v;
        unchecked {
            _v.old_10 = ((_epochLen > MIN_EPOCH_LENGTH) && (_epochLen < type(uint32).max)) && (epochLen != _epochLen);
            _v.old_11 = ((_epochLen > MIN_EPOCH_LENGTH) && (_epochLen < type(uint32).max)) && (epochLen != _epochLen);
            _v.old_12 = maxBond;
            _v.old_13 = effectiveBond;
            _v.old_14 = maxBond;
            _v.old_15 = maxBond;
            _v.old_16 = effectiveBond;
            _v.old_17 = maxBond;
        }
        _original_Tokenomics_changeTokenomicsParameters(_devsPerCapital, _epsilonRate, _epochLen, _veOLASThreshold);
        unchecked {
            if (!((!(epochCounter > 1)) || (mapEpochTokenomics[epochCounter - 1].epochPoint.endTime > mapEpochTokenomics[epochCounter - 2].epochPoint.endTime))) {
                emit AssertionFailed("16: ep is correct endTime");
                assert(false);
            }
            if (!((!_v.old_10) || (epochLen == _epochLen))) {
                emit AssertionFailed("17: epochLen");
                assert(false);
            }
            if (!((!((_devsPerCapital > 0) && (_devsPerCapital < type(uint32).max))) || (mapEpochTokenomics[epochCounter].epochPoint.devsPerCapital == _devsPerCapital))) {
                emit AssertionFailed("18: devsPerCapital");
                assert(false);
            }
            if (!((!((_epsilonRate > 0) && (_epsilonRate < 17000000000000000000))) || (epsilonRate == _epsilonRate))) {
                emit AssertionFailed("19: epsilonRate");
                assert(false);
            }
            if (!((!_v.old_11) || (maxBond == (((inflationPerSecond * mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction) * _epochLen) / 100)))) {
                emit AssertionFailed("20: maxBond");
                assert(false);
            }
            if (!((!(_v.old_12 > maxBond)) || (effectiveBond == (_v.old_13 - (_v.old_14 - maxBond))))) {
                emit AssertionFailed("21: new effectiveBond with curMaxBond > nextMaxBond");
                assert(false);
            }
            if (!((!(maxBond > _v.old_15)) || (effectiveBond == (_v.old_16 + (maxBond - _v.old_17))))) {
                emit AssertionFailed("22: new effectiveBond with curMaxBond < nextMaxBond");
                assert(false);
            }
            if (!((!((_veOLASThreshold > 0) && (_veOLASThreshold < type(uint96).max))) || (veOLASThreshold == _veOLASThreshold))) {
                emit AssertionFailed("23: veOLASThreshold");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_changeTokenomicsParameters(uint256 _devsPerCapital, uint256 _epsilonRate, uint256 _epochLen, uint256 _veOLASThreshold) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if (_devsPerCapital > 0) {
            mapEpochTokenomics[epochCounter].epochPoint.devsPerCapital = uint32(_devsPerCapital);
        } else {
            _devsPerCapital = mapEpochTokenomics[epochCounter].epochPoint.devsPerCapital;
        }
        if ((_epsilonRate > 0) && (_epsilonRate < 17e18)) {
            epsilonRate = uint64(_epsilonRate);
        } else {
            _epsilonRate = epsilonRate;
        }
        uint256 oldEpochLen = epochLen;
        if (((_epochLen + 1) > MIN_EPOCH_LENGTH) && (oldEpochLen != _epochLen)) {
            if (lockMaxBond == 2) {
                revert MaxBondUpdateLocked();
            }
            if (_epochLen > oldEpochLen) {
                uint256 lastEpochEndTime = mapEpochTokenomics[epochCounter - 1].epochPoint.endTime;
                uint256 numYears = ((lastEpochEndTime + _epochLen) - timeLaunch) / ONE_YEAR;
                if (numYears > currentYear) {
                    revert MaxBondUpdateLocked();
                }
            }
            uint256 nextMaxBond = ((inflationPerSecond * mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction) * _epochLen) / 100;
            _adjustMaxBond(nextMaxBond);
            epochLen = uint32(_epochLen);
            emit EpochLengthUpdated(_epochLen);
        } else {
            _epochLen = epochLen;
        }
        if (_veOLASThreshold > 0) {
            veOLASThreshold = uint96(_veOLASThreshold);
        } else {
            _veOLASThreshold = veOLASThreshold;
        }
        emit TokenomicsParametersUpdated(_devsPerCapital, _epsilonRate, _epochLen, _veOLASThreshold);
    }

    function changeIncentiveFractions(uint256 _rewardComponentFraction, uint256 _rewardAgentFraction, uint256 _maxBondFraction, uint256 _topUpComponentFraction, uint256 _topUpAgentFraction) external {
        vars3 memory _v;
        unchecked {
            _v.old_18 = mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction != _maxBondFraction;
            _v.old_19 = maxBond;
            _v.old_20 = effectiveBond;
            _v.old_21 = maxBond;
            _v.old_22 = maxBond;
            _v.old_23 = effectiveBond;
            _v.old_24 = maxBond;
        }
        _original_Tokenomics_changeIncentiveFractions(_rewardComponentFraction, _rewardAgentFraction, _maxBondFraction, _topUpComponentFraction, _topUpAgentFraction);
        unchecked {
            if (!((!(epochCounter >= 2)) || (mapEpochTokenomics[epochCounter - 1].epochPoint.endTime > mapEpochTokenomics[epochCounter - 2].epochPoint.endTime))) {
                emit AssertionFailed("24: ep is correct endTime");
                assert(false);
            }
            if (!(mapEpochTokenomics[epochCounter].epochPoint.maxBondFraction > 0)) {
                emit AssertionFailed("25: ep is correct maxBondFraction");
                assert(false);
            }
            if (!((!_v.old_18) || (maxBond == (((inflationPerSecond * _maxBondFraction) * epochLen) / 100)))) {
                emit AssertionFailed("26: maxBond");
                assert(false);
            }
            if (!((!(_v.old_19 > maxBond)) || (effectiveBond == (_v.old_20 - (_v.old_21 - maxBond))))) {
                emit AssertionFailed("27: new effectiveBond with curMaxBond > nextMaxBond");
                assert(false);
            }
            if (!((!(maxBond > _v.old_22)) || (effectiveBond == (_v.old_23 + (maxBond - _v.old_24))))) {
                emit AssertionFailed("28: new effectiveBond with curMaxBond < nextMaxBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_changeIncentiveFractions(uint256 _rewardComponentFraction, uint256 _rewardAgentFraction, uint256 _maxBondFraction, uint256 _topUpComponentFraction, uint256 _topUpAgentFraction) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if ((_rewardComponentFraction + _rewardAgentFraction) > 100) {
            revert WrongAmount(_rewardComponentFraction + _rewardAgentFraction, 100);
        }
        if (((_maxBondFraction + _topUpComponentFraction) + _topUpAgentFraction) > 100) {
            revert WrongAmount((_maxBondFraction + _topUpComponentFraction) + _topUpAgentFraction, 100);
        }
        TokenomicsPoint storage tp = mapEpochTokenomics[epochCounter];
        tp.unitPoints[0].rewardUnitFraction = uint8(_rewardComponentFraction);
        tp.unitPoints[1].rewardUnitFraction = uint8(_rewardAgentFraction);
        tp.epochPoint.rewardTreasuryFraction = uint8((100 - _rewardComponentFraction) - _rewardAgentFraction);
        uint256 oldMaxBondFraction = tp.epochPoint.maxBondFraction;
        if (oldMaxBondFraction != _maxBondFraction) {
            if (lockMaxBond == 2) {
                revert MaxBondUpdateLocked();
            }
            uint256 nextMaxBond = ((inflationPerSecond * _maxBondFraction) * epochLen) / 100;
            _adjustMaxBond(nextMaxBond);
            tp.epochPoint.maxBondFraction = uint8(_maxBondFraction);
        }
        tp.unitPoints[0].topUpUnitFraction = uint8(_topUpComponentFraction);
        tp.unitPoints[1].topUpUnitFraction = uint8(_topUpAgentFraction);
        emit IncentiveFractionsUpdated(_rewardComponentFraction, _rewardAgentFraction, _maxBondFraction, _topUpComponentFraction, _topUpAgentFraction);
    }

    function reserveAmountForBondProgram(uint256 amount) external returns (bool success) {
        vars4 memory _v;
        unchecked {
            _v.old_25 = effectiveBond;
            _v.old_26 = effectiveBond;
        }
        success = _original_Tokenomics_reserveAmountForBondProgram(amount);
        unchecked {
            if (!((!(_v.old_25 > amount)) || (effectiveBond == (_v.old_26 - amount)))) {
                emit AssertionFailed("29: effectiveBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_reserveAmountForBondProgram(uint256 amount) private returns (bool success) {
        if (depository != msg.sender) {
            revert ManagerOnly(msg.sender, depository);
        }
        uint256 eBond = effectiveBond;
        if ((eBond + 1) > amount) {
            eBond -= amount;
            effectiveBond = uint96(eBond);
            success = true;
            emit EffectiveBondUpdated(eBond);
        }
    }

    function refundFromBondProgram(uint256 amount) external {
        vars5 memory _v;
        unchecked {
            _v.old_27 = effectiveBond + amount;
            _v.old_28 = effectiveBond;
        }
        _original_Tokenomics_refundFromBondProgram(amount);
        unchecked {
            if (!((!(_v.old_27 < 79228162514264337593543950336)) || (effectiveBond == (_v.old_28 + amount)))) {
                emit AssertionFailed("30: effectiveBond");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_refundFromBondProgram(uint256 amount) private {
        if (depository != msg.sender) {
            revert ManagerOnly(msg.sender, depository);
        }
        uint256 eBond = effectiveBond + amount;
        effectiveBond = uint96(eBond);
        emit EffectiveBondUpdated(eBond);
    }

    /// @dev Finalizes epoch incentives for a specified component / agent Id.
    ///  @param epochNum Epoch number to finalize incentives for.
    ///  @param unitType Unit type (component / agent).
    ///  @param unitId Unit Id.
    function _finalizeIncentivesForUnitId(uint256 epochNum, uint256 unitType, uint256 unitId) internal {
        uint256 totalIncentives = mapUnitIncentives[unitType][unitId].pendingRelativeReward;
        if (totalIncentives > 0) {
            totalIncentives *= mapEpochTokenomics[epochNum].epochPoint.totalDonationsETH;
            totalIncentives *= mapEpochTokenomics[epochNum].unitPoints[unitType].rewardUnitFraction;
            uint256 sumUnitIncentives = mapEpochTokenomics[epochNum].unitPoints[unitType].sumUnitDonationsETH * 100;
            totalIncentives = mapUnitIncentives[unitType][unitId].reward + (totalIncentives / sumUnitIncentives);
            mapUnitIncentives[unitType][unitId].reward = uint96(totalIncentives);
            mapUnitIncentives[unitType][unitId].pendingRelativeReward = 0;
        }
        totalIncentives = mapUnitIncentives[unitType][unitId].pendingRelativeTopUp;
        if (totalIncentives > 0) {
            totalIncentives *= mapEpochTokenomics[epochNum].epochPoint.totalTopUpsOLAS;
            totalIncentives *= mapEpochTokenomics[epochNum].unitPoints[unitType].topUpUnitFraction;
            uint256 sumUnitIncentives = mapEpochTokenomics[epochNum].unitPoints[unitType].sumUnitTopUpsOLAS * 100;
            totalIncentives = mapUnitIncentives[unitType][unitId].topUp + (totalIncentives / sumUnitIncentives);
            mapUnitIncentives[unitType][unitId].topUp = uint96(totalIncentives);
            mapUnitIncentives[unitType][unitId].pendingRelativeTopUp = 0;
        }
    }

    /// @dev Records service donations into corresponding data structures.
    ///  @param serviceIds Set of service Ids.
    ///  @param amounts Correspondent set of ETH amounts provided by services.
    ///  @param curEpoch Current epoch number.
    function _trackServiceDonations(uint256[] memory serviceIds, uint256[] memory amounts, uint256 curEpoch) internal {
        address[] memory registries = new address[](2);
        (registries[0], registries[1]) = (componentRegistry, agentRegistry);
        bool[] memory incentiveFlags = new bool[](4);
        incentiveFlags[0] = (mapEpochTokenomics[curEpoch].unitPoints[0].rewardUnitFraction > 0);
        incentiveFlags[1] = (mapEpochTokenomics[curEpoch].unitPoints[1].rewardUnitFraction > 0);
        incentiveFlags[2] = (mapEpochTokenomics[curEpoch].unitPoints[0].topUpUnitFraction > 0);
        incentiveFlags[3] = (mapEpochTokenomics[curEpoch].unitPoints[1].topUpUnitFraction > 0);
        uint256 numServices = serviceIds.length;
        for (uint256 i = 0; i < numServices; ++i) {
            uint96 amount = uint96(amounts[i]);
            bool topUpEligible;
            if (incentiveFlags[2] || incentiveFlags[3]) {
                address serviceOwner = IToken(serviceRegistry).ownerOf(serviceIds[i]);
                topUpEligible = (IVotingEscrow(ve).getVotes(serviceOwner) > veOLASThreshold) ? true : false;
            }
            for (uint256 unitType = 0; unitType < 2; ++unitType) {
                (uint256 numServiceUnits, uint32[] memory serviceUnitIds) = IServiceRegistry(serviceRegistry).getUnitIdsOfService(IServiceRegistry.UnitType(unitType), serviceIds[i]);
                if (numServiceUnits == 0) {
                    revert ServiceNeverDeployed(serviceIds[i]);
                }
                if (incentiveFlags[unitType] || incentiveFlags[unitType + 2]) {
                    for (uint256 j = 0; j < numServiceUnits; ++j) {
                        uint256 lastEpoch = mapUnitIncentives[unitType][serviceUnitIds[j]].lastEpoch;
                        if (lastEpoch == 0) {
                            mapUnitIncentives[unitType][serviceUnitIds[j]].lastEpoch = uint32(curEpoch);
                        } else if (lastEpoch < curEpoch) {
                            _finalizeIncentivesForUnitId(lastEpoch, unitType, serviceUnitIds[j]);
                            mapUnitIncentives[unitType][serviceUnitIds[j]].lastEpoch = uint32(curEpoch);
                        }
                        if (incentiveFlags[unitType]) {
                            mapUnitIncentives[unitType][serviceUnitIds[j]].pendingRelativeReward += amount;
                            mapEpochTokenomics[curEpoch].unitPoints[unitType].sumUnitDonationsETH += amount;
                        }
                        if (topUpEligible && incentiveFlags[unitType + 2]) {
                            mapUnitIncentives[unitType][serviceUnitIds[j]].pendingRelativeTopUp += amount;
                            mapEpochTokenomics[curEpoch].unitPoints[unitType].sumUnitTopUpsOLAS += amount;
                        }
                    }
                }
                for (uint256 j = 0; j < numServiceUnits; ++j) {
                    if (!mapNewUnits[unitType][serviceUnitIds[j]]) {
                        mapNewUnits[unitType][serviceUnitIds[j]] = true;
                        mapEpochTokenomics[curEpoch].unitPoints[unitType].numNewUnits++;
                        address unitOwner = IToken(registries[unitType]).ownerOf(serviceUnitIds[j]);
                        if (!mapNewOwners[unitOwner]) {
                            mapNewOwners[unitOwner] = true;
                            mapEpochTokenomics[curEpoch].epochPoint.numNewOwners++;
                        }
                    }
                }
            }
        }
    }

    function trackServiceDonations(address donator, uint256[] memory serviceIds, uint256[] memory amounts, uint256 donationETH) external {
        vars6 memory _v;
        unchecked {
            _v.old_29 = mapEpochTokenomics[epochCounter].epochPoint.totalDonationsETH;
            _v.old_30 = mapEpochTokenomics[epochCounter].epochPoint.totalDonationsETH;
            _v.old_31 = mapEpochTokenomics[epochCounter].epochPoint.numNewOwners;
        }
        _original_Tokenomics_trackServiceDonations(donator, serviceIds, amounts, donationETH);
        unchecked {
            if (!((!((_v.old_29 + donationETH) < 79228162514264337593543950336)) || (mapEpochTokenomics[epochCounter].epochPoint.totalDonationsETH == (_v.old_30 + donationETH)))) {
                emit AssertionFailed("31: totalDonationsETH can only increase");
                assert(false);
            }
            if (!(mapEpochTokenomics[epochCounter].epochPoint.numNewOwners >= _v.old_31)) {
                emit AssertionFailed("32: numNewOwners can only increase");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_trackServiceDonations(address donator, uint256[] memory serviceIds, uint256[] memory amounts, uint256 donationETH) private {
        if (treasury != msg.sender) {
            revert ManagerOnly(msg.sender, treasury);
        }
        address bList = donatorBlacklist;
        if ((bList != address(0)) && IDonatorBlacklist(bList).isDonatorBlacklisted(donator)) {
            revert DonatorBlacklisted(donator);
        }
        uint256 numServices = serviceIds.length;
        for (uint256 i = 0; i < numServices; ++i) {
            if (!IServiceRegistry(serviceRegistry).exists(serviceIds[i])) {
                revert ServiceDoesNotExist(serviceIds[i]);
            }
        }
        uint256 curEpoch = epochCounter;
        donationETH = mapEpochTokenomics[curEpoch].epochPoint.totalDonationsETH + donationETH;
        mapEpochTokenomics[curEpoch].epochPoint.totalDonationsETH = uint96(donationETH);
        _trackServiceDonations(serviceIds, amounts, curEpoch);
    }

    function checkpoint() external returns (bool RET_0) {
        vars7 memory _v;
        unchecked {
            _v.old_32 = epochCounter;
            _v.old_33 = currentYear;
            _v.old_34 = currentYear;
        }
        RET_0 = _original_Tokenomics_checkpoint();
        unchecked {
            if (!((!(RET_0 == true)) || (epochCounter == (_v.old_32 + 1)))) {
                emit AssertionFailed("33: epochCounter can only increase");
                assert(false);
            }
            if (!((!((RET_0 == true) && (((block.timestamp - timeLaunch) / ONE_YEAR) > _v.old_33))) || (currentYear == (_v.old_34 + 1)))) {
                emit AssertionFailed("34: two events will never happen at the same time");
                assert(false);
            }
        }
    }

    function _original_Tokenomics_checkpoint() private returns (bool) {
        address implementation;
        assembly {
            implementation := sload(PROXY_TOKENOMICS)
        }
        if (implementation == address(0)) {
            revert DelegatecallOnly();
        }
        uint256 prevEpochTime = mapEpochTokenomics[epochCounter - 1].epochPoint.endTime;
        uint256 diffNumSeconds = block.timestamp - prevEpochTime;
        uint256 curEpochLen = epochLen;
        if (diffNumSeconds < curEpochLen) {
            return false;
        }
        uint256 eCounter = epochCounter;
        TokenomicsPoint storage tp = mapEpochTokenomics[eCounter];
        uint256[] memory incentives = new uint256[](7);
        incentives[0] = tp.epochPoint.totalDonationsETH;
        incentives[1] = (incentives[0] * tp.epochPoint.rewardTreasuryFraction) / 100;
        incentives[2] = (incentives[0] * tp.unitPoints[0].rewardUnitFraction) / 100;
        incentives[3] = (incentives[0] * tp.unitPoints[1].rewardUnitFraction) / 100;
        uint256 inflationPerEpoch;
        uint256 curMaxBond = maxBond;
        uint256 numYears = (block.timestamp - timeLaunch) / ONE_YEAR;
        if (numYears > currentYear) {
            uint256 curInflationPerSecond = inflationPerSecond;
            uint256 yearEndTime = timeLaunch + (numYears * ONE_YEAR);
            inflationPerEpoch = (yearEndTime - prevEpochTime) * curInflationPerSecond;
            curInflationPerSecond = getInflationForYear(numYears) / ONE_YEAR;
            inflationPerEpoch += (block.timestamp - yearEndTime) * curInflationPerSecond;
            maxBond = uint96((curInflationPerSecond * curEpochLen) * tp.epochPoint.maxBondFraction) / 100;
            inflationPerSecond = uint96(curInflationPerSecond);
            currentYear = uint8(numYears);
            lockMaxBond = 1;
        } else {
            inflationPerEpoch = inflationPerSecond * diffNumSeconds;
        }
        tp.epochPoint.totalTopUpsOLAS = uint96(inflationPerEpoch);
        incentives[4] = (inflationPerEpoch * tp.epochPoint.maxBondFraction) / 100;
        if (incentives[4] > curMaxBond) {
            incentives[4] = (effectiveBond + incentives[4]) - curMaxBond;
            effectiveBond = uint96(incentives[4]);
        }
        numYears = ((block.timestamp + curEpochLen) - timeLaunch) / ONE_YEAR;
        if (numYears > currentYear) {
            uint256 curInflationPerSecond = inflationPerSecond;
            uint256 yearEndTime = timeLaunch + (numYears * ONE_YEAR);
            curMaxBond = (((yearEndTime - block.timestamp) * curInflationPerSecond) * tp.epochPoint.maxBondFraction) / 100;
            curInflationPerSecond = getInflationForYear(numYears) / ONE_YEAR;
            curMaxBond += ((((block.timestamp + curEpochLen) - yearEndTime) * curInflationPerSecond) * tp.epochPoint.maxBondFraction) / 100;
            maxBond = uint96(curMaxBond);
            lockMaxBond = 2;
        } else {
            curMaxBond = maxBond;
        }
        curMaxBond += effectiveBond;
        effectiveBond = uint96(curMaxBond);
        uint64 idf;
        if (incentives[0] > 0) {
            uint256 codeUnits = ((tp.unitPoints[1].unitWeight * tp.unitPoints[0].numNewUnits) + (tp.unitPoints[0].unitWeight * tp.unitPoints[1].numNewUnits));
            UD60x18 fp1 = UD60x18.wrap(incentives[1]);
            UD60x18 fp2 = toUD60x18(codeUnits * tp.epochPoint.devsPerCapital);
            fp1 = fp1.mul(fp2);
            fp2 = toUD60x18(codeUnits * tp.epochPoint.numNewOwners);
            UD60x18 fp = fp1.add(fp2);
            fp = fp.div(wrap((100 * tp.unitPoints[0].unitWeight) * tp.unitPoints[1].unitWeight));
            uint256 fKD = UD60x18.unwrap(fp);
            if (fKD > epsilonRate) {
                fKD = epsilonRate;
            }
            idf = uint64(1e18 + fKD);
        }
        tp.epochPoint.endTime = uint32(block.timestamp);
        uint256 accountRewards = incentives[2] + incentives[3];
        incentives[5] = (inflationPerEpoch * tp.unitPoints[0].topUpUnitFraction) / 100;
        incentives[6] = (inflationPerEpoch * tp.unitPoints[1].topUpUnitFraction) / 100;
        uint256 accountTopUps = incentives[5] + incentives[6];
        if ((incentives[1] == 0) || ITreasury(treasury).rebalanceTreasury(incentives[1])) {
            emit EpochSettled(eCounter, incentives[1], accountRewards, accountTopUps);
            eCounter++;
            epochCounter = uint32(eCounter);
        } else {
            revert TreasuryRebalanceFailed(eCounter);
        }
        TokenomicsPoint storage nextPoint = mapEpochTokenomics[eCounter];
        for (uint256 i = 0; i < 2; ++i) {
            nextPoint.unitPoints[i].topUpUnitFraction = tp.unitPoints[i].topUpUnitFraction;
            nextPoint.unitPoints[i].rewardUnitFraction = tp.unitPoints[i].rewardUnitFraction;
            nextPoint.unitPoints[i].unitWeight = tp.unitPoints[i].unitWeight;
        }
        nextPoint.epochPoint.rewardTreasuryFraction = tp.epochPoint.rewardTreasuryFraction;
        nextPoint.epochPoint.maxBondFraction = tp.epochPoint.maxBondFraction;
        nextPoint.epochPoint.devsPerCapital = tp.epochPoint.devsPerCapital;
        nextPoint.epochPoint.idf = idf;
        return true;
    }

    /// @dev Gets inflation per last epoch.
    ///  @return inflationPerEpoch Inflation value.
    function getInflationPerEpoch() external view returns (uint256 inflationPerEpoch) {
        inflationPerEpoch = inflationPerSecond * epochLen;
    }

    /// @dev Gets epoch point of a specified epoch number.
    ///  @param epoch Epoch number.
    ///  @return ep Epoch point.
    function getEpochPoint(uint256 epoch) external view returns (EpochPoint memory ep) {
        ep = mapEpochTokenomics[epoch].epochPoint;
    }

    /// @dev Gets component / agent point of a specified epoch number and a unit type.
    ///  @param epoch Epoch number.
    ///  @param unitType Component (0) or agent (1).
    ///  @return up Unit point.
    function getUnitPoint(uint256 epoch, uint256 unitType) external view returns (UnitPoint memory up) {
        up = mapEpochTokenomics[epoch].unitPoints[unitType];
    }

    /// @dev Gets inverse discount factor with the multiple of 1e18.
    ///  @param epoch Epoch number.
    ///  @return idf Discount factor with the multiple of 1e18.
    function getIDF(uint256 epoch) external view returns (uint256 idf) {
        idf = mapEpochTokenomics[epoch].epochPoint.idf;
        if (idf == 0) {
            idf = 1e18;
        }
    }

    /// @dev Gets inverse discount factor with the multiple of 1e18 of the last epoch.
    ///  @return idf Discount factor with the multiple of 1e18.
    function getLastIDF() external view returns (uint256 idf) {
        idf = mapEpochTokenomics[epochCounter - 1].epochPoint.idf;
        if (idf == 0) {
            idf = 1e18;
        }
    }

    /// @dev Gets component / agent owner incentives and clears the balances.
    ///  @notice `account` must be the owner of components / agents Ids, otherwise the function will revert.
    ///  @notice If not all `unitIds` belonging to `account` were provided, they will be untouched and keep accumulating.
    ///  @notice Component and agent Ids must be provided in the ascending order and must not repeat.
    ///  @param account Account address.
    ///  @param unitTypes Set of unit types (component / agent).
    ///  @param unitIds Set of corresponding unit Ids where account is the owner.
    ///  @return reward Reward amount.
    ///  @return topUp Top-up amount.
    function accountOwnerIncentives(address account, uint256[] memory unitTypes, uint256[] memory unitIds) external returns (uint256 reward, uint256 topUp) {
        if (dispenser != msg.sender) {
            revert ManagerOnly(msg.sender, dispenser);
        }
        if (unitTypes.length != unitIds.length) {
            revert WrongArrayLength(unitTypes.length, unitIds.length);
        }
        address[] memory registries = new address[](2);
        (registries[0], registries[1]) = (componentRegistry, agentRegistry);
        uint256[] memory registriesSupply = new uint256[](2);
        for (uint256 i = 0; i < 2; ++i) {
            registriesSupply[i] = IToken(registries[i]).totalSupply();
        }
        uint256[] memory lastIds = new uint256[](2);
        for (uint256 i = 0; i < unitIds.length; ++i) {
            if (unitTypes[i] > 1) {
                revert Overflow(unitTypes[i], 1);
            }
            if ((unitIds[i] < (lastIds[unitTypes[i]] + 1)) || (unitIds[i] > registriesSupply[unitTypes[i]])) {
                revert WrongUnitId(unitIds[i], unitTypes[i]);
            }
            lastIds[unitTypes[i]] = unitIds[i];
            address unitOwner = IToken(registries[unitTypes[i]]).ownerOf(unitIds[i]);
            if (unitOwner != account) {
                revert OwnerOnly(unitOwner, account);
            }
        }
        uint256 curEpoch = epochCounter;
        for (uint256 i = 0; i < unitIds.length; ++i) {
            uint256 lastEpoch = mapUnitIncentives[unitTypes[i]][unitIds[i]].lastEpoch;
            if ((lastEpoch > 0) && (lastEpoch < curEpoch)) {
                _finalizeIncentivesForUnitId(lastEpoch, unitTypes[i], unitIds[i]);
                mapUnitIncentives[unitTypes[i]][unitIds[i]].lastEpoch = 0;
            }
            reward += mapUnitIncentives[unitTypes[i]][unitIds[i]].reward;
            mapUnitIncentives[unitTypes[i]][unitIds[i]].reward = 0;
            topUp += mapUnitIncentives[unitTypes[i]][unitIds[i]].topUp;
            mapUnitIncentives[unitTypes[i]][unitIds[i]].topUp = 0;
        }
    }

    /// @dev Gets the component / agent owner incentives.
    ///  @notice `account` must be the owner of components / agents they are passing, otherwise the function will revert.
    ///  @param account Account address.
    ///  @param unitTypes Set of unit types (component / agent).
    ///  @param unitIds Set of corresponding unit Ids where account is the owner.
    ///  @return reward Reward amount.
    ///  @return topUp Top-up amount.
    function getOwnerIncentives(address account, uint256[] memory unitTypes, uint256[] memory unitIds) external view returns (uint256 reward, uint256 topUp) {
        if (unitTypes.length != unitIds.length) {
            revert WrongArrayLength(unitTypes.length, unitIds.length);
        }
        address[] memory registries = new address[](2);
        (registries[0], registries[1]) = (componentRegistry, agentRegistry);
        uint256[] memory registriesSupply = new uint256[](2);
        for (uint256 i = 0; i < 2; ++i) {
            registriesSupply[i] = IToken(registries[i]).totalSupply();
        }
        uint256[] memory lastIds = new uint256[](2);
        for (uint256 i = 0; i < unitIds.length; ++i) {
            if (unitTypes[i] > 1) {
                revert Overflow(unitTypes[i], 1);
            }
            if ((unitIds[i] < (lastIds[unitTypes[i]] + 1)) || (unitIds[i] > registriesSupply[unitTypes[i]])) {
                revert WrongUnitId(unitIds[i], unitTypes[i]);
            }
            lastIds[unitTypes[i]] = unitIds[i];
            address unitOwner = IToken(registries[unitTypes[i]]).ownerOf(unitIds[i]);
            if (unitOwner != account) {
                revert OwnerOnly(unitOwner, account);
            }
        }
        uint256 curEpoch = epochCounter;
        for (uint256 i = 0; i < unitIds.length; ++i) {
            uint256 lastEpoch = mapUnitIncentives[unitTypes[i]][unitIds[i]].lastEpoch;
            if ((lastEpoch > 0) && (lastEpoch < curEpoch)) {
                uint256 totalIncentives = mapUnitIncentives[unitTypes[i]][unitIds[i]].pendingRelativeReward;
                if (totalIncentives > 0) {
                    totalIncentives *= mapEpochTokenomics[lastEpoch].epochPoint.totalDonationsETH;
                    totalIncentives *= mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].rewardUnitFraction;
                    uint256 sumUnitIncentives = mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].sumUnitDonationsETH * 100;
                    reward += totalIncentives / sumUnitIncentives;
                }
                totalIncentives = mapUnitIncentives[unitTypes[i]][unitIds[i]].pendingRelativeTopUp;
                if (totalIncentives > 0) {
                    totalIncentives *= mapEpochTokenomics[lastEpoch].epochPoint.totalTopUpsOLAS;
                    totalIncentives *= mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].topUpUnitFraction;
                    uint256 sumUnitIncentives = mapEpochTokenomics[lastEpoch].unitPoints[unitTypes[i]].sumUnitTopUpsOLAS * 100;
                    topUp += totalIncentives / sumUnitIncentives;
                }
            }
            reward += mapUnitIncentives[unitTypes[i]][unitIds[i]].reward;
            topUp += mapUnitIncentives[unitTypes[i]][unitIds[i]].topUp;
        }
    }

    /// @dev Gets incentive balances of a component / agent.
    ///  @notice Note that these numbers are not final values per epoch, since more donations might be given
    ///          and incentive fractions are subject to change by the governance.
    ///  @param unitType Unit type (component or agent).
    ///  @param unitId Unit Id.
    ///  @return Component / agent incentive balances.
    function getIncentiveBalances(uint256 unitType, uint256 unitId) external view returns (IncentiveBalances memory) {
        return mapUnitIncentives[unitType][unitId];
    }
}