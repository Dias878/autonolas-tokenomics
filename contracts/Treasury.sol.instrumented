/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./GenericTokenomics.sol";
import "./interfaces/IOLAS.sol";
import "./interfaces/IServiceTokenomics.sol";
import "./interfaces/ITokenomics.sol";
import "hardhat/console.sol";
import "hardhat/node_modules/ansi-colors/__scribble_ReentrancyUtils.sol";

/// @title Treasury - Smart contract for managing OLAS Treasury
///  @author AL
///  @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>
/// #invariant {:msg "broken conservation law"} address(this).balance == ETHFromServices+ETHOwned; 
contract Treasury is __scribble_ReentrancyUtils, GenericTokenomics {
    enum TokenState { NonExistent, Enabled, Disabled }

    event DepositTokenFromAccount(address indexed account, address indexed token, uint256 tokenAmount, uint256 olasAmount);

    event DepositETHFromServices(address indexed sender, uint256 donation);

    event Withdraw(address indexed token, uint256 tokenAmount);

    event TokenReserves(address indexed token, uint256 reserves);

    event EnableToken(address indexed token);

    event DisableToken(address indexed token);

    event TransferToDispenserOLAS(uint256 amount);

    event ReceivedETH(address indexed sender, uint256 amount);

    event TreasuryPaused();

    event TreasuryUnpaused();

    struct TokenInfo {
        TokenState state;
        uint224 reserves;
    }

    struct vars4 {
        uint96 old_0;
    }

    struct vars5 {
        uint256 old_1;
    }

    struct vars6 {
        uint96 old_2;
    }

    struct vars7 {
        uint96 old_3;
        uint96 old_4;
    }

    struct vars8 {
        uint96 old_5;
        uint96 old_6;
    }

    struct vars11 {
        uint256 old_7;
        uint96 old_8;
    }

    uint96 public ETHFromServices;
    uint96 public ETHOwned;
    uint8 public paused = 1;
    mapping(address => TokenInfo) public mapTokens;
    address[] public tokenRegistry;
    address public constant ETH_TOKEN_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);

    /// @dev Treasury constructor.
    ///  @param _olas OLAS token address.
    ///  @param _depository Depository address.
    ///  @param _tokenomics Tokenomics address.
    ///  @param _dispenser Dispenser address.
    constructor(address _olas, address _depository, address _tokenomics, address _dispenser) payable GenericTokenomics() {
        __scribble_out_of_contract = false;
        super.initialize(_olas, _tokenomics, address(this), _depository, _dispenser, TokenomicsRole.Treasury);
        ETHOwned = uint96(msg.value);
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    receive() external payable {
        vars4 memory _v;
        __scribble_out_of_contract = false;
        unchecked {
            _v.old_0 = ETHFromServices;
        }
        _original_Treasury_receive();
        unchecked {
            if (!(_v.old_0 == ETHFromServices)) {
                emit AssertionFailed("1: we do not touch the balance of developers");
                assert(false);
            }
            if (!(address(this).balance == (ETHFromServices + ETHOwned))) {
                emit AssertionFailed("2: conservation law");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_receive() private {
        uint96 amount = ETHOwned;
        amount += uint96(msg.value);
        ETHOwned = amount;
        emit ReceivedETH(msg.sender, msg.value);
    }

    function depositTokenForOLAS(address account, uint256 tokenAmount, address token, uint256 olasMintAmount) external {
        vars5 memory _v;
        __scribble_out_of_contract = false;
        unchecked {
            _v.old_1 = address(this).balance;
        }
        _original_Treasury_depositTokenForOLAS(account, tokenAmount, token, olasMintAmount);
        unchecked {
            if (!(_v.old_1 == address(this).balance)) {
                emit AssertionFailed("3: we do not touch the total eth balance");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_depositTokenForOLAS(address account, uint256 tokenAmount, address token, uint256 olasMintAmount) private {
        if (depository != msg.sender) {
            revert ManagerOnly(msg.sender, depository);
        }
        TokenInfo storage tokenInfo = mapTokens[token];
        if (tokenInfo.state != TokenState.Enabled) {
            revert UnauthorizedToken(token);
        }
        uint256 reserves = tokenInfo.reserves + tokenAmount;
        tokenInfo.reserves = uint224(reserves);
        if (_callsite_579(IERC20(token), account, address(this)) < tokenAmount) {
            revert InsufficientAllowance(_callsite_593(IERC20(token), (account), address(this)), tokenAmount);
        }
        _callsite_609(IERC20(token), account, address(this), tokenAmount);
        _callsite_618(IOLAS(olas), msg.sender, olasMintAmount);
        emit DepositTokenFromAccount(account, token, tokenAmount, olasMintAmount);
    }

    function depositServiceDonationsETH(uint256[] memory serviceIds, uint256[] memory amounts) external payable {
        vars6 memory _v;
        __scribble_out_of_contract = false;
        unchecked {
            _v.old_2 = ETHOwned;
        }
        _original_Treasury_depositServiceDonationsETH(serviceIds, amounts);
        unchecked {
            if (!(_v.old_2 == ETHOwned)) {
                emit AssertionFailed("4: we do not touch the owners balance");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_depositServiceDonationsETH(uint256[] memory serviceIds, uint256[] memory amounts) private {
        if (msg.value == 0) {
            revert ZeroValue();
        }
        uint256 numServices = serviceIds.length;
        if (amounts.length != numServices) {
            revert WrongArrayLength(numServices, amounts.length);
        }
        uint256 totalAmount;
        for (uint256 i = 0; i < numServices; ++i) {
            if (amounts[i] == 0) {
                revert ZeroValue();
            }
            totalAmount += amounts[i];
        }
        if (msg.value != totalAmount) {
            revert WrongAmount(msg.value, totalAmount);
        }
        console.log("ETH sended", msg.value);
        console.log("ETHFromServices before", ETHFromServices);
        uint256 donationETH = _callsite_732(ITokenomics(tokenomics), msg.sender, serviceIds, amounts);
        int256 delta = int256(msg.value - donationETH);
        console.log("delta");
        console.logInt(delta);
        console.log("donationETH calc", donationETH);
        donationETH += ETHFromServices;
        ETHFromServices = uint96(donationETH);
        console.log("ETHFromServices after", ETHFromServices);
        emit DepositETHFromServices(msg.sender, donationETH);
    }

    function withdraw(address to, uint256 tokenAmount, address token) external returns (bool success) {
        vars7 memory _v;
        __scribble_out_of_contract = false;
        unchecked {
            _v.old_3 = ETHFromServices;
            _v.old_4 = ETHOwned;
        }
        success = _original_Treasury_withdraw(to, tokenAmount, token);
        unchecked {
            if (!(_v.old_3 == ETHFromServices)) {
                emit AssertionFailed("5: we do not touch the balance of developers");
                assert(false);
            }
            if (!((!(token == ETH_TOKEN_ADDRESS)) || (ETHOwned == (_v.old_4 - tokenAmount)))) {
                emit AssertionFailed("6: updated ETHOwned");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_withdraw(address to, uint256 tokenAmount, address token) private returns (bool success) {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        if (token == ETH_TOKEN_ADDRESS) {
            uint96 amountOwned = ETHOwned;
            if ((amountOwned + 1) > tokenAmount) {
                amountOwned -= uint96(tokenAmount);
                ETHOwned = amountOwned;
                emit Withdraw(address(0), tokenAmount);
                (success, ) = _callsite_851(to, tokenAmount, "");
                if (!success) {
                    revert TransferFailed(address(0), address(this), to, tokenAmount);
                }
            } else {
                revert AmountLowerThan(tokenAmount, amountOwned);
            }
        } else {
            TokenInfo storage tokenInfo = mapTokens[token];
            if (tokenInfo.state != TokenState.Enabled) {
                revert UnauthorizedToken(token);
            }
            uint256 reserves = tokenInfo.reserves;
            reserves -= tokenAmount;
            tokenInfo.reserves = uint224(reserves);
            success = true;
            emit Withdraw(token, tokenAmount);
            _callsite_931(IERC20(token), to, tokenAmount);
        }
    }

    function withdrawToAccount(address account, uint256 accountRewards, uint256 accountTopUps) external returns (bool success) {
        vars8 memory _v;
        __scribble_out_of_contract = false;
        unchecked {
            _v.old_5 = ETHOwned;
            _v.old_6 = ETHFromServices;
        }
        success = _original_Treasury_withdrawToAccount(account, accountRewards, accountTopUps);
        unchecked {
            if (!(_v.old_5 == ETHOwned)) {
                emit AssertionFailed("7: we do not touch the owners balance");
                assert(false);
            }
            if (!((!((accountRewards > 0) && (ETHFromServices >= accountRewards))) || (ETHFromServices == (_v.old_6 - accountRewards)))) {
                emit AssertionFailed("8: updated ETHFromServices");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_withdrawToAccount(address account, uint256 accountRewards, uint256 accountTopUps) private returns (bool success) {
        if (paused == 2) {
            revert Paused();
        }
        if (dispenser != msg.sender) {
            revert ManagerOnly(msg.sender, dispenser);
        }
        uint256 amountETHFromServices = ETHFromServices;
        if ((accountRewards > 0) && (amountETHFromServices >= accountRewards)) {
            amountETHFromServices -= accountRewards;
            ETHFromServices = uint96(amountETHFromServices);
            (success, ) = _callsite_997(account, accountRewards, "");
            if (!success) {
                revert TransferFailed(address(0), address(this), treasury, accountRewards);
            }
        }
        if (accountTopUps > 0) {
            _callsite_1028(IOLAS(olas), account, accountTopUps);
            success = true;
            emit TransferToDispenserOLAS(accountTopUps);
        }
    }

    function enableToken(address token) external {
        __scribble_out_of_contract = false;
        _original_Treasury_enableToken(token);
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_enableToken(address token) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        TokenState state = mapTokens[token].state;
        if (state != TokenState.Enabled) {
            if (state == TokenState.NonExistent) {
                tokenRegistry.push(token);
            }
            mapTokens[token].state = TokenState.Enabled;
            emit EnableToken(token);
        }
    }

    function disableToken(address token) external {
        __scribble_out_of_contract = false;
        _original_Treasury_disableToken(token);
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_disableToken(address token) private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        TokenInfo storage tokenInfo = mapTokens[token];
        if (tokenInfo.state != TokenState.Disabled) {
            if (tokenInfo.reserves > 0) {
                revert NonZeroValue();
            }
            tokenInfo.state = TokenState.Disabled;
            emit DisableToken(token);
        }
    }

    /// @dev Gets information about token being enabled for bonding.
    ///  @param token Token address.
    ///  @return enabled True if token is enabled.
    function isEnabled(address token) external view returns (bool enabled) {
        enabled = (mapTokens[token].state == TokenState.Enabled);
    }

    function rebalanceTreasury(uint256 treasuryRewards) external returns (bool success) {
        vars11 memory _v;
        __scribble_out_of_contract = false;
        unchecked {
            _v.old_7 = address(this).balance;
            _v.old_8 = ETHFromServices + ETHOwned;
        }
        success = _original_Treasury_rebalanceTreasury(treasuryRewards);
        unchecked {
            if (!(_v.old_7 == address(this).balance)) {
                emit AssertionFailed("9: we do not touch the total eth balance");
                assert(false);
            }
            if (!(_v.old_8 == (ETHFromServices + ETHOwned))) {
                emit AssertionFailed("10: conservation law");
                assert(false);
            }
        }
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_rebalanceTreasury(uint256 treasuryRewards) private returns (bool success) {
        if (paused == 2) {
            revert Paused();
        }
        if (msg.sender != tokenomics) {
            revert ManagerOnly(msg.sender, tokenomics);
        }
        success = true;
        if (treasuryRewards > 0) {
            uint256 amountETHFromServices = ETHFromServices;
            if (amountETHFromServices >= treasuryRewards) {
                amountETHFromServices -= treasuryRewards;
                uint256 amountETHOwned = ETHOwned;
                amountETHOwned += treasuryRewards;
                ETHOwned = uint96(amountETHOwned);
                ETHFromServices = uint96(amountETHFromServices);
            } else {
                success = false;
            }
        }
    }

    function drainServiceSlashedFunds() external returns (uint256 amount) {
        __scribble_out_of_contract = false;
        amount = _original_Treasury_drainServiceSlashedFunds();
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_drainServiceSlashedFunds() private returns (uint256 amount) {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        address serviceRegistry = _callsite_1273(ITokenomics(tokenomics));
        amount = _callsite_1280(IServiceTokenomics(serviceRegistry));
    }

    function pause() external {
        __scribble_out_of_contract = false;
        _original_Treasury_pause();
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_pause() private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        paused = 2;
        emit TreasuryPaused();
    }

    function unpause() external {
        __scribble_out_of_contract = false;
        _original_Treasury_unpause();
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
    }

    function _original_Treasury_unpause() private {
        if (msg.sender != owner) {
            revert OwnerOnly(msg.sender, owner);
        }
        paused = 1;
        emit TreasuryUnpaused();
    }

    /// Check only the current contract's state invariants
    function __scribble_Treasury_check_state_invariants_internal() internal {
        unchecked {
            if (!(address(this).balance == (ETHFromServices + ETHOwned))) {
                emit AssertionFailed("0: broken conservation law");
                assert(false);
            }
        }
    }

    /// Check the state invariant for the current contract and all its bases
    function __scribble_check_state_invariants() virtual override internal {
        __scribble_Treasury_check_state_invariants_internal();
        __scribble_GenericTokenomics_check_state_invariants_internal();
    }

    function _callsite_579(IERC20 receiver, address arg0, address arg1) private returns (uint256 ret0) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0) = receiver.allowance(arg0, arg1);
        __scribble_out_of_contract = false;
    }

    function _callsite_593(IERC20 receiver, address arg0, address arg1) private returns (uint256 ret0) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0) = receiver.allowance(arg0, arg1);
        __scribble_out_of_contract = false;
    }

    function _callsite_609(IERC20 receiver, address arg0, address arg1, uint256 arg2) private returns (bool ret0) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0) = receiver.transferFrom(arg0, arg1, arg2);
        __scribble_out_of_contract = false;
    }

    function _callsite_618(IOLAS receiver, address arg0, uint256 arg1) private {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        receiver.mint(arg0, arg1);
        __scribble_out_of_contract = false;
    }

    function _callsite_732(ITokenomics receiver, address arg0, uint256[] memory arg1, uint256[] memory arg2) private returns (uint256 ret0) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0) = receiver.trackServiceDonations(arg0, arg1, arg2);
        __scribble_out_of_contract = false;
    }

    function _callsite_851(address receiver, uint256 _value, bytes memory arg0) private returns (bool ret0, bytes memory ret1) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0, ret1) = receiver.call{value: _value}(arg0);
        __scribble_out_of_contract = false;
    }

    function _callsite_931(IERC20 receiver, address arg0, uint256 arg1) private returns (bool ret0) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0) = receiver.transfer(arg0, arg1);
        __scribble_out_of_contract = false;
    }

    function _callsite_997(address receiver, uint256 _value, bytes memory arg0) private returns (bool ret0, bytes memory ret1) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0, ret1) = receiver.call{value: _value}(arg0);
        __scribble_out_of_contract = false;
    }

    function _callsite_1028(IOLAS receiver, address arg0, uint256 arg1) private {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        receiver.mint(arg0, arg1);
        __scribble_out_of_contract = false;
    }

    function _callsite_1273(ITokenomics receiver) private returns (address ret0) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0) = receiver.serviceRegistry();
        __scribble_out_of_contract = false;
    }

    function _callsite_1280(IServiceTokenomics receiver) private returns (uint256 ret0) {
        __scribble_check_state_invariants();
        __scribble_out_of_contract = true;
        (ret0) = receiver.drain();
        __scribble_out_of_contract = false;
    }
}